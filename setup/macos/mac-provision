#!/usr/bin/env bash
#/ macOS system provisioning and configuration helper
#/
#/ Usage: $(basename "$0") [options]
#/
#/ Options:
#/   -h, --help             Show this help and exit
#/   -v, --verbose          Enable verbose logging
#/   -y, --yes              Assume "yes" to interactive prompts
#/       --non-interactive  Fail instead of prompting when input is required
#/       --dry-run          Print the actions that would run without mutating the system
#/       --update-brewfile  Regenerate setup/macos/Brewfile from the current Homebrew state
#/       --update-defaults  Refresh setup/macos/defaults.conf using current macOS defaults
#/       --update-only      Perform update actions and exit without running provisioning steps
#/
#/ Examples:
#/   $(basename "$0")
#/   $(basename "$0") --dry-run
#/   $(basename "$0") --update-brewfile --update-defaults --update-only

set -Eeuo pipefail
trap script.cleanup SIGINT SIGTERM ERR EXIT

source "$(dirname "$0")/../../lib/bash/initrc"

script_dir=$(cd "$(dirname "${BASH_SOURCE[0]}")" &>/dev/null && pwd -P)
repo_root=$(cd "$script_dir/../.." &>/dev/null && pwd -P)
BREWFILE_PATH="$script_dir/Brewfile"
DEFAULTS_FILE="$script_dir/defaults.conf"

verbose=0
assume_yes=0
non_interactive=0
dry_run=0
update_brewfile=0
update_defaults=0
update_only=0

declare -a SUMMARY_CHANGES=()
declare -a SUMMARY_WARNINGS=()
declare -a DEFAULTS_ENTRIES=()

summary.add() {
  SUMMARY_CHANGES+=("$1")
}

summary.warn() {
  SUMMARY_WARNINGS+=("$1")
}

summary.print() {
  if ((${#SUMMARY_CHANGES[@]})); then
    log.info "Summary of changes"
    local item
    for item in "${SUMMARY_CHANGES[@]}"; do
      printf '  - %s\n' "$item"
    done
  fi

  if ((${#SUMMARY_WARNINGS[@]})); then
    log.warn "Items requiring attention"
    local warn
    for warn in "${SUMMARY_WARNINGS[@]}"; do
      printf '    %s\n' "$warn"
    done
  fi
}

preferred_brew_prefix() {
  local arch
  arch=$(uname -m 2>/dev/null || echo "x86_64")
  if [[ $arch == "arm64" ]]; then
    echo "/opt/homebrew"
  else
    echo "/usr/local"
  fi
}

expand_path() {
  local value="$1"
  if [[ $value == ~* ]]; then
    echo "${value/#\~/$HOME}"
  else
    echo "$value"
  fi
}

compact_path() {
  local value="$1"
  if [[ $value == "$HOME"* ]]; then
    echo "~${value#$HOME}"
  else
    echo "$value"
  fi
}

macos_defaults_load() {
  DEFAULTS_ENTRIES=()
  if [[ ! -f $DEFAULTS_FILE ]]; then
    summary.warn "Defaults config not found at $DEFAULTS_FILE"
    return 1
  fi

  while IFS= read -r line || [[ -n $line ]]; do
    [[ -z ${line//[[:space:]]/} ]] && continue
    [[ ${line#\#} != "$line" ]] && continue
    DEFAULTS_ENTRIES+=("$line")
  done <"$DEFAULTS_FILE"
}

macos_defaults_normalize() {
  local type="$1" value="$2"
  case "$type" in
  bool)
    case "$value" in
    1 | true | TRUE | yes | YES | on | ON) echo "true" ;;
    0 | false | FALSE | no | NO | off | OFF) echo "false" ;;
    *) echo "$value" ;;
    esac
    ;;
  string)
    echo "$value"
    ;;
  int | float)
    echo "$value"
    ;;
  *)
    echo "$value"
    ;;
  esac
}

macos_defaults_read() {
  local domain="$1" key="$2" type="$3" value
  if ! value=$(defaults read "$domain" "$key" 2>/dev/null); then
    return 1
  fi
  value=$(printf '%s' "$value" | tr -d '\n')
  macos_defaults_normalize "$type" "$value"
}

macos_defaults_write() {
  local domain="$1" key="$2" type="$3" value="$4"
  case "$type" in
  bool)
    local normalized
    normalized=$(macos_defaults_normalize "$type" "$value")
    defaults write "$domain" "$key" -bool "$normalized"
    ;;
  int)
    defaults write "$domain" "$key" -int "$value"
    ;;
  float)
    defaults write "$domain" "$key" -float "$value"
    ;;
  string)
    local expanded
    expanded=$(expand_path "$value")
    defaults write "$domain" "$key" -string "$expanded"
    ;;
  raw)
    # raw entries must contain the full command after the key
    eval defaults write "$domain" "$key" $value
    ;;
  *)
    log.warn "Unsupported defaults type '$type' for $domain $key"
    return 1
    ;;
  esac
}

macos_defaults_update_file() {
  if [[ ! -f $DEFAULTS_FILE ]]; then
    log.warn "Cannot update defaults; $DEFAULTS_FILE missing"
    return 1
  fi

  macos_defaults_load || return 1

  local tmp
  tmp=$(mktemp)

  {
    echo "# domain|key|type|value"
    echo "# Updated $(date -u +%Y-%m-%dT%H:%M:%SZ)"
    echo
  } >"$tmp"

  local entry domain key type value current normalized
  for entry in "${DEFAULTS_ENTRIES[@]}"; do
    IFS='|' read -r domain key type value <<<"$entry"
    if [[ -z $domain || -z $key ]]; then
      echo "$entry" >>"$tmp"
      continue
    fi

    case "$type" in
    bool | int | float | string)
      if current=$(macos_defaults_read "$domain" "$key" "$type"); then
        if [[ $type == "string" ]]; then
          current=$(compact_path "$current")
        fi
        printf '%s|%s|%s|%s\n' "$domain" "$key" "$type" "$current" >>"$tmp"
      else
        log.warn "Removing missing default: $domain $key"
      fi
      ;;
    *)
      printf '%s\n' "$entry" >>"$tmp"
      ;;
    esac
  done

  if ((dry_run)); then
    log.info "[dry-run] Would update $DEFAULTS_FILE"
    rm -f "$tmp"
    return 0
  fi

  mv "$tmp" "$DEFAULTS_FILE"
  summary.add "Updated defaults config ($DEFAULTS_FILE)"
  return 0
}

directory_is_hidden() {
  local path="$1" flags
  flags=$(ls -ldO "$path" 2>/dev/null | awk '{print $5}') || return 1
  [[ $flags == "hidden" ]]
}

ensure_directory_flag() {
  local path="$1" desired="$2"

  if [[ ! -e $path ]]; then
    summary.warn "Directory $path does not exist"
    return
  fi

  if [[ $desired == "hidden" ]]; then
    if directory_is_hidden "$path"; then
      ((verbose)) && log.info "$path already hidden"
      return
    fi
    summary.add "Hide $path"
    if ((dry_run)); then
      log.info "[dry-run] Would hide $path"
      return
    fi
    chflags hidden "$path"
  else
    if ! directory_is_hidden "$path"; then
      ((verbose)) && log.info "$path already visible"
      return
    fi
    summary.add "Unhide $path"
    if ((dry_run)); then
      log.info "[dry-run] Would unhide $path"
      return
    fi
    chflags nohidden "$path"
  fi
}

brew_exists() {
  command -v brew >/dev/null 2>&1
}

brew_prefix_actual() {
  if brew_exists; then
    brew --prefix 2>/dev/null || preferred_brew_prefix
  else
    preferred_brew_prefix
  fi
}

ensure_homebrew_prefix_permissions() {
  local prefix="$1"
  if ((dry_run)); then
    log.info "[dry-run] Would ensure permissions on $prefix"
    return
  fi

  if [[ -d $prefix ]]; then
    if [[ ! -w $prefix ]]; then
      sudo chown -R "$LOGNAME:admin" "$prefix"
    fi
  else
    sudo mkdir -p "$prefix"
    sudo chflags norestricted "$prefix"
    sudo chown -R "$LOGNAME:admin" "$prefix"
  fi
}

run_step() {
  local label="$1" func="$2"
  printf '\n'
  if ((dry_run)); then
    log.info "==> $label (dry-run)"
  else
    log.info "==> $label"
  fi
  "$func"
}

step_sudo_keepalive() {
  if ((dry_run)); then
    log.info "[dry-run] Would request sudo keep-alive"
    return 0
  fi

  if ! command -v sudo >/dev/null 2>&1; then
    summary.warn "sudo not available; continuing without privilege escalation"
    return 0
  fi

  log.info "Requesting sudo credentials (you may be prompted)"
  sudo -v
  (
    while true; do
      sudo -n true >/dev/null 2>&1 || exit
      sleep 60
      kill -0 "$$" || exit
    done
  ) &
}

step_setup_xcode() {
  local need_install=0
  if ! xcode-select -p >/dev/null 2>&1; then
    need_install=1
  fi

  if ((need_install)); then
    summary.add "Install Xcode Command Line Tools"
    if ((dry_run)); then
      log.info "[dry-run] Would install Xcode Command Line Tools"
    else
      log.info "Triggering Xcode Command Line Tools installer"
      xcode-select --install >/dev/null 2>&1 || log.warn "Installer may already be running"
      until xcode-select -p >/dev/null 2>&1; do
        sleep 10
      done
    fi
  else
    ((verbose)) && log.info "Xcode Command Line Tools already installed"
  fi

  if command -v xcodebuild >/dev/null 2>&1; then
    if ! sudo xcodebuild -license status >/dev/null 2>&1; then
      summary.add "Accept Xcode license"
      if ((dry_run)); then
        log.info "[dry-run] Would accept the Xcode license"
      else
        sudo xcodebuild -license accept
      fi
    fi
  fi
}

step_setup_homebrew() {
  if brew_exists; then
    ((verbose)) && log.info "Homebrew detected at $(brew_prefix_actual)"
    return 0
  fi

  local prefix installer="https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh"
  prefix=$(preferred_brew_prefix)
  summary.add "Install Homebrew into $prefix"

  if ((dry_run)); then
    log.info "[dry-run] Would install Homebrew and adjust PATH"
    return 0
  fi

  ensure_homebrew_prefix_permissions "$prefix"
  /bin/bash -c "$(curl -fsSL "$installer")"

  if [[ -x "$prefix/bin/brew" ]]; then
    PATH="$prefix/bin:$PATH"
    export PATH
  fi
}

step_ensure_brew_bundle() {
  if [[ ! -f $BREWFILE_PATH ]]; then
    summary.warn "Brewfile missing at $BREWFILE_PATH; skipping bundle"
    return 0
  fi

  if ! brew_exists; then
    summary.warn "Homebrew not available; cannot apply Brewfile"
    return 0
  fi

  local check_output
  if check_output=$(brew bundle check --file="$BREWFILE_PATH" 2>&1); then
    ((verbose)) && printf '%s\n' "$check_output"
    return 0
  fi

  summary.add "Install missing Homebrew formulas from Brewfile"
  printf '%s\n' "$check_output"

  if ((dry_run)); then
    log.info "[dry-run] Would run: brew bundle install --file=\"$BREWFILE_PATH\""
    return 0
  fi

  brew bundle --file="$BREWFILE_PATH"
}

step_setup_default_file_associations() {
  if ! command -v duti >/dev/null 2>&1; then
    summary.warn "duti not installed; skipping file association setup"
    return 0
  fi

  if ((dry_run)); then
    log.info "[dry-run] Would refresh default file associations with duti"
    return 0
  fi

  if ! command -v curl >/dev/null 2>&1 || ! command -v yq >/dev/null 2>&1; then
    summary.warn "curl or yq missing; cannot rebuild default associations"
    return 0
  fi

  summary.add "Refresh default file associations via duti"
  if ! ui.loader.run "Refreshing file associations" -- bash -c '
    set -euo pipefail
    curl -fsSL "https://raw.githubusercontent.com/github/linguist/master/lib/linguist/languages.yml" \
      | yq e "to_entries | (map(.value.extensions) | flatten) - [null] | unique | .[]" \
      | xargs -L 1 -I {} duti -s com.todesktop.230313mzl4w4u92 {} all
  '; then
    summary.warn "Failed to update file associations"
  fi
}

step_apply_user_defaults() {
  macos_defaults_load || return 0

  local entry domain key type value
  local current normalized_current normalized_target
  local -a apply_queue=()
  local changes=0 dock_restart=0 finder_restart=0 ui_restart=0
  local screenshot_dir=""

  for entry in "${DEFAULTS_ENTRIES[@]}"; do
    IFS='|' read -r domain key type value <<<"$entry"
    [[ -z $domain || -z $key ]] && continue

    normalized_target=$(macos_defaults_normalize "$type" "$value")
    if current=$(macos_defaults_read "$domain" "$key" "$type"); then
      normalized_current="$current"
    else
      normalized_current=""
    fi

    if [[ $normalized_target != "$normalized_current" ]]; then
      summary.add "defaults: $domain $key -> $normalized_target (was ${normalized_current:-unset})"
      log.info "defaults: $domain $key -> $normalized_target (was ${normalized_current:-unset})"
      apply_queue+=("$domain|$key|$type|$value")
      ((changes++))

      case "$domain" in
      com.apple.dock) dock_restart=1 ;;
      com.apple.finder) finder_restart=1 ;;
      com.apple.screencapture)
        ui_restart=1
        if [[ $key == "location" ]]; then
          screenshot_dir=$(expand_path "$value")
        fi
        ;;
      esac
    else
      ((verbose)) && log.info "defaults: $domain $key already $normalized_target"
    fi
  done

  if ((changes == 0)); then
    log.info "macOS defaults already aligned"
    return 0
  fi

  if ((dry_run)); then
    log.info "[dry-run] Skipping defaults write for $changes keys"
    if [[ -n $screenshot_dir ]]; then
      log.info "[dry-run] Would ensure directory $screenshot_dir exists"
    fi
    return 0
  fi

  ui.loader.start "Applying macOS defaults"
  local item
  for item in "${apply_queue[@]}"; do
    IFS='|' read -r domain key type value <<<"$item"
    macos_defaults_write "$domain" "$key" "$type" "$value"
  done
  ui.loader.ok

  if [[ -n $screenshot_dir ]]; then
    mkdir -p "$screenshot_dir"
  fi

  if ((dock_restart)); then
    killall Dock >/dev/null 2>&1 || true
  fi
  if ((finder_restart)); then
    killall Finder >/dev/null 2>&1 || true
  fi
  if ((ui_restart)); then
    killall SystemUIServer >/dev/null 2>&1 || true
  fi
  killall cfprefsd >/dev/null 2>&1 || true
}

step_configure_directories() {
  ensure_directory_flag "$HOME/Library" "visible"
  ensure_directory_flag "$HOME/Music" "hidden"
  ensure_directory_flag "$HOME/Movies" "hidden"
  ensure_directory_flag "$HOME/Pictures" "hidden"
  ensure_directory_flag "$HOME/Public" "hidden"
}

step_configure_shell_profiles() {
  local profile_local="$HOME/.profile.local"
  local machine_id_file="$HOME/.machine_id"

  if [[ ! -f $profile_local ]]; then
    summary.add "Create $profile_local"
    if ((dry_run)); then
      log.info "[dry-run] Would create $profile_local"
    else
      touch "$profile_local"
    fi
  fi

  local machine_id
  if ! machine_id=$(ioreg -rd1 -c IOPlatformExpertDevice | awk -F'"' '/IOPlatformUUID/{print $4}' | head -n 1); then
    summary.warn "Unable to query IOPlatformUUID; skipping $machine_id_file update"
    return 0
  fi
  machine_id=${machine_id//$'\n'/}

  if [[ -z $machine_id ]]; then
    summary.warn "IOPlatformUUID lookup returned empty result; skipping $machine_id_file update"
    return 0
  fi

  local current=""
  if [[ -f $machine_id_file ]]; then
    current=$(<"$machine_id_file")
    current=${current//$'\n'/}
  fi

  if [[ $machine_id != "$current" ]]; then
    summary.add "Write machine identifier to $machine_id_file"
    if ((dry_run)); then
      log.info "[dry-run] Would write machine identifier to $machine_id_file"
    else
      printf '%s\n' "$machine_id" >"$machine_id_file"
    fi
  elif ((verbose)); then
    log.info "$machine_id_file already contains current machine identifier"
  fi
}

step_install_pipx() {
  if command -v pipx >/dev/null 2>&1; then
    if ((dry_run)); then
      log.info "[dry-run] Would refresh pipx environment"
      return 0
    fi
    pipx ensurepath >/dev/null 2>&1 || true
    sudo pipx --global ensurepath >/dev/null 2>&1 || true
    pipx completions >/dev/null 2>&1 || true
    return 0
  fi

  summary.add "Install pipx via Homebrew"
  if ((dry_run)); then
    log.info "[dry-run] Would install pipx"
    return 0
  fi

  if ! brew_exists; then
    summary.warn "Homebrew not available; cannot install pipx"
    return 0
  fi

  brew install pipx
  pipx ensurepath >/dev/null 2>&1 || true
  sudo pipx --global ensurepath >/dev/null 2>&1 || true
  pipx completions >/dev/null 2>&1 || true
}

step_configure_copyx_launchd() {
  local copyx_bin="$repo_root/bin/copyx"

  if [[ ! -x $copyx_bin ]]; then
    summary.warn "copyx helper missing at $copyx_bin; skipping LaunchAgent setup"
    return 0
  fi

  if ((dry_run)); then
    log.info "[dry-run] Would run: $copyx_bin --launchd-load"
    summary.add "Load copyx LaunchAgent"
    return 0
  fi

  if "$copyx_bin" --launchd-load; then
    summary.add "Loaded copyx LaunchAgent"
  else
    summary.warn "Failed to load copyx LaunchAgent"
    return 1
  fi
}

step_enable_firewall() {
  if ! command -v sudo >/dev/null 2>&1; then
    summary.warn "sudo unavailable; skipping firewall configuration"
    return 0
  fi

  local status
  status=$(sudo /usr/libexec/ApplicationFirewall/socketfilterfw --getglobalstate 2>/dev/null || true)
  if [[ $status == *"State = 1"* ]]; then
    ((verbose)) && log.info "Firewall already enabled"
    return 0
  fi

  summary.add "Enable application firewall"
  if ((dry_run)); then
    log.info "[dry-run] Would enable the application firewall"
    return 0
  fi

  sudo /usr/libexec/ApplicationFirewall/socketfilterfw --setglobalstate on >/dev/null 2>&1
}

step_quit_system_preferences() {
  if ((dry_run)); then
    log.info "[dry-run] Would quit System Preferences"
    return 0
  fi
  osascript -e 'tell application "System Preferences" to quit' >/dev/null 2>&1 || true
}

update_brewfile_from_system() {
  if ! brew_exists; then
    summary.warn "Homebrew not installed; cannot update Brewfile"
    return 1
  fi

  if ((dry_run)); then
    log.info "[dry-run] Would run: brew bundle dump --file=\"$BREWFILE_PATH\" --force"
    summary.add "Brewfile would be regenerated from current system"
    return 0
  fi

  if ui.loader.run "Updating Brewfile" -- brew bundle dump --file="$BREWFILE_PATH" --force; then
    summary.add "Brewfile updated from current system"
  else
    summary.warn "Failed to update Brewfile"
    return 1
  fi
}

parse_args() {
  while [[ $# -gt 0 ]]; do
    case "$1" in
    -h | --help)
      script.usage
      ;;
    -v | --verbose)
      verbose=1
      ;;
    -y | --yes)
      assume_yes=1
      ;;
    --non-interactive)
      non_interactive=1
      ;;
    --dry-run)
      dry_run=1
      ;;
    --update-brewfile)
      update_brewfile=1
      ;;
    --update-defaults)
      update_defaults=1
      ;;
    --update-only)
      update_only=1
      ;;
    --)
      shift
      break
      ;;
    --*)
      log.error "Unknown option: $1"
      script.usage 1
      ;;
    *)
      log.error "Unexpected positional argument: $1"
      script.usage 1
      ;;
    esac
    shift
  done

  if [[ $# -gt 0 ]]; then
    log.error "Unexpected positional arguments: $*"
    script.usage 1
  fi
}

main() {
  parse_args "$@"

  if ((update_brewfile)); then
    update_brewfile_from_system
  fi

  if ((update_defaults)); then
    macos_defaults_update_file
  fi

  if ((update_only)); then
    summary.print
    return 0
  fi

  if ! prompt.ask_yes_no 'Proceed with macOS system provisioning?' "$assume_yes" "$non_interactive" "$verbose"; then
    log.warn "Aborted by user"
    return 1
  fi

  local start_time end_time duration
  start_time=$(date +%s)

  run_step "Request sudo keep-alive" step_sudo_keepalive
  run_step "Install Xcode Command Line Tools" step_setup_xcode
  run_step "Ensure Homebrew" step_setup_homebrew
  run_step "Apply Brew bundle" step_ensure_brew_bundle
  run_step "Refresh file associations" step_setup_default_file_associations
  run_step "Apply macOS defaults" step_apply_user_defaults
  run_step "Configure special directories" step_configure_directories
  run_step "Ensure shell profile files" step_configure_shell_profiles
  run_step "Quit System Preferences" step_quit_system_preferences
  run_step "Ensure pipx" step_install_pipx
  run_step "Load copyx LaunchAgent" step_configure_copyx_launchd
  run_step "Enable firewall" step_enable_firewall

  end_time=$(date +%s)
  duration=$((end_time - start_time))

  printf '\n'
  summary.print
  log.info "✨ Done in ${duration}s."
}

main "$@"
