#!/usr/bin/env bash

# Helper utilities for the copyx backup script.

copyx.trim() {
  local s=""
  if (( $# )); then
    s="$1"
  else
    s=$(cat)
  fi
  s="${s#"${s%%[![:space:]]*}"}"
  s="${s%"${s##*[![:space:]]}"}"
  printf '%s' "$s"
}

copyx.expand_env() {
  local value="$1"
  if [[ -z "$value" ]]; then
    printf '%s\n' "$value"
    return
  fi
  if [[ "$value" == *'${HOME}'* ]]; then
    value="${value//\$\{HOME\}/$HOME}"
  fi
  if [[ "$value" == *'$HOME'* ]]; then
    value="${value//\$HOME/$HOME}"
  fi
  printf '%s\n' "$value"
}

copyx.pattern_to_glob() {
  local pattern="$1" base_dir="$2"
  pattern=$(copyx.expand_env "$pattern")
  if [[ -n "$pattern" && ${pattern:0:1} == '~' ]]; then
    case "$pattern" in
      "~") pattern="$HOME" ;;
      ~/*) pattern="$HOME/${pattern:2}" ;;
    esac
  elif [[ -n "$base_dir" && "$pattern" != /* ]]; then
    pattern="$base_dir/$pattern"
  fi
  printf '%s\n' "$pattern"
}

copyx.resolve_path() {
  local path="$1" base_dir="${2:-$PWD}"
  path=$(copyx.expand_env "$path")
  if [[ -n "$path" && ${path:0:1} == '~' ]]; then
    case "$path" in
      "~") path="$HOME" ;;
      ~/*) path="$HOME/${path:2}" ;;
    esac
  fi
  if [[ -n "$base_dir" && "$path" != /* ]]; then
    path="$base_dir/$path"
  fi
  if command -v realpath >/dev/null 2>&1; then
    realpath "$path" 2>/dev/null || printf '%s\n' "$path"
    return
  fi
  local dir part
  dir=$(dirname -- "$path")
  part=$(basename -- "$path")
  (
    cd "$dir" 2>/dev/null && printf '%s/%s\n' "$(pwd)" "$part"
  ) || printf '%s\n' "$path"
}

copyx.strip_trailing_slashes() {
  local value="$1"
  while [[ -n "$value" && "$value" != "/" && ${value: -1} == '/' ]]; do
    value="${value%/}"
  done
  printf '%s\n' "$value"
}

copyx.join_paths() {
  local base="$1" suffix="$2"
  if [[ -z "$suffix" ]]; then
    printf '%s\n' "$base"
    return
  fi
  if [[ -z "$base" ]]; then
    printf '%s\n' "$suffix"
    return
  fi
  if [[ ${base: -1} == '/' ]]; then
    printf '%s%s\n' "$base" "$suffix"
  else
    printf '%s/%s\n' "$base" "$suffix"
  fi
}

copyx.backend_for_root() {
  local destination="$1"
  if [[ "$destination" == s3://* ]]; then
    printf 's3\n'
  else
    printf 'local\n'
  fi
}

copyx.ensure_backend_prerequisites() {
  local backend="$1"
  case "$backend" in
    local)
      if ! command -v rsync >/dev/null 2>&1; then
        log.error "rsync is required for local backups but not found in PATH"
        exit 1
      fi
      ;;
    s3)
      if ! command -v aws >/dev/null 2>&1; then
        log.error "aws CLI is required for S3 backups but not found in PATH"
        exit 1
      fi
      ;;
  esac
}

copyx.on_battery_power() {
  if command -v pmset >/dev/null 2>&1; then
    local status
    status=$(pmset -g batt 2>/dev/null | head -n 1 || true)
    if [[ "$status" == *"Battery Power"* ]]; then
      return 0
    fi
    if [[ "$status" == *"AC Power"* ]]; then
      return 1
    fi
  elif command -v upower >/dev/null 2>&1; then
    local battery state_line state
    battery=$(upower -e 2>/dev/null | grep -m1 battery || true)
    if [[ -n "$battery" ]]; then
      state_line=$(upower -i "$battery" 2>/dev/null | grep -i 'state' | head -n1 || true)
      state=${state_line##*: }
      state=$(printf '%s' "$state" | tr '[:upper:]' '[:lower:]')
      if [[ "$state" == "discharging" ]]; then
        return 0
      fi
      if [[ "$state" == "charging" || "$state" == "fully-charged" ]]; then
        return 1
      fi
    fi
  elif command -v acpi >/dev/null 2>&1; then
    local acpi_out
    acpi_out=$(acpi -a 2>/dev/null | head -n1 || true)
    if [[ "$acpi_out" == *"off-line"* ]]; then
      return 0
    fi
    if [[ "$acpi_out" == *"on-line"* ]]; then
      return 1
    fi
  fi
  return 1
}

copyx.update_s3_history_log() {
  local destination_root="$1" entry="$2"
  local log_object
  log_object=$(copyx.join_paths "$destination_root" "logs/history.log")
  local tmp
  tmp=$(mktemp) || return 1
  if aws s3 cp "$log_object" "$tmp" --only-show-errors >/dev/null 2>&1; then
    :
  fi
  printf '%s\n' "$entry" >>"$tmp"
  if ! aws s3 cp "$tmp" "$log_object" --only-show-errors >/dev/null 2>&1; then
    log.warn "Failed to update history log at $log_object"
  fi
  rm -f "$tmp"
}

copyx.relative_dest_path() {
  local path="$1" home_path="${2:-$HOME}" home_name rest
  while [[ "$path" != "/" && "${path: -1}" == "/" ]]; do
    path="${path%/}"
  done
  if [[ -n "$home_path" && "$path" == "$home_path"* ]]; then
    home_name=$(basename -- "$home_path")
    rest="${path#"$home_path"}"
    rest="${rest#/}"
    if [[ -n "$rest" ]]; then
      printf 'home/%s/%s\n' "$home_name" "$rest"
    else
      printf 'home/%s\n' "$home_name"
    fi
    return
  fi
  path="${path#/}"
  if [[ -z "$path" ]]; then
    printf 'root\n'
  else
    printf '%s\n' "$path"
  fi
}

copyx.xml_escape() {
  local value="$1"
  value="${value//&/&amp;}"
  value="${value//</&lt;}"
  value="${value//>/&gt;}"
  value="${value//\"/&quot;}"
  value="${value//\'/&apos;}"
  printf '%s\n' "$value"
}
