#!/usr/bin/env bash

# OS and platform helpers similar in spirit to Python's os and sys modules.
os.devnull() {
  "$@" 2>/dev/null >/dev/null
}

os.setenv() {
  export "${1}"="${2}"
}

os.getenv() {
  env | grep "^$1=" | cut -d'=' -f2
}

sys.platform() {
  if [[ -n ${_SYS_PLATFORM:-} ]]; then
    echo "$_SYS_PLATFORM"
    return 0
  fi
  _SYS_PLATFORM=$(uname -s | tr "[:upper:]" "[:lower:]")
  echo "$_SYS_PLATFORM"
}

os.platform.is_darwin() {
  [[ $(sys.platform) == darwin ]]
}

os.platform.is_linux() {
  [[ $(sys.platform) == linux ]]
}

os.path.exists() {
  [[ -f $1 ]]
}

sys.path.contains() {
  os.devnull command -v "$1"
}

sys.path.prepend() {
  [[ -d $1 ]] && PATH="$1:${PATH}"
}

sys.path.append() {
  [[ -d $1 ]] && PATH="${PATH}:$1"
}

sys.path.prepend_many() {
  local d
  for d in "$@"; do
    sys.path.prepend "$d"
  done
}

sys.path.append_many() {
  local d
  for d in "$@"; do
    sys.path.append "$d"
  done
}

clip.copy() {
  if os.platform.is_darwin; then
    pbcopy
  else
    xclip -selection clipboard
  fi
}

clip.paste() {
  if os.platform.is_darwin; then
    pbpaste
  else
    xclip -selection clipboard -o
  fi
}

os.rename_safe() {
  local source="$1" target="$2"
  [[ -n $source && -n $target ]] || return 1
  if [[ $source == "$target" ]]; then
    return 0
  fi
  mv -n -- "$source" "$target"
}

# Returns success if $HOME/.machine_id matches the current IOPlatformUUID.
os.machine_id.matches_current() {
  if [[ -n ${_MACHINE_ID_MATCHES:-} ]]; then
    ((_MACHINE_ID_MATCHES == 1))
    return
  fi

  local machine_id_file="$HOME/.machine_id"
  local stored hw_uuid

  os.platform.is_darwin || { _MACHINE_ID_MATCHES=0; return 1; }
  sys.path.contains ioreg || { _MACHINE_ID_MATCHES=0; return 1; }
  [[ -f $machine_id_file ]] || { _MACHINE_ID_MATCHES=0; return 1; }

  stored=$(<"$machine_id_file")
  stored=${stored//$'\n'/}
  [[ -n $stored ]] || { _MACHINE_ID_MATCHES=0; return 1; }

  if ! hw_uuid=$(ioreg -rd1 -c IOPlatformExpertDevice | awk -F'"' '/IOPlatformUUID/{print $4}' | head -n 1); then
    _MACHINE_ID_MATCHES=0
    return 1
  fi
  hw_uuid=${hw_uuid//$'\n'/}
  [[ -n $hw_uuid ]] || { _MACHINE_ID_MATCHES=0; return 1; }

  if [[ $stored == "$hw_uuid" ]]; then
    _MACHINE_ID_MATCHES=1
    return 0
  else
    _MACHINE_ID_MATCHES=0
    return 1
  fi
}

os.on_battery_power() {
  if command -v pmset >/dev/null 2>&1; then
    local status
    status=$(pmset -g batt 2>/dev/null | head -n 1 || true)
    if [[ $status == *"Battery Power"* ]]; then
      return 0
    fi
    if [[ $status == *"AC Power"* ]]; then
      return 1
    fi
  elif command -v upower >/dev/null 2>&1; then
    local battery state_line state
    battery=$(upower -e 2>/dev/null | grep -m1 battery || true)
    if [[ -n $battery ]]; then
      state_line=$(upower -i "$battery" 2>/dev/null | grep -i 'state' | head -n1 || true)
      state=${state_line##*: }
      state=$(printf '%s' "$state" | tr '[:upper:]' '[:lower:]')
      if [[ $state == "discharging" ]]; then
        return 0
      fi
      if [[ $state == "charging" || $state == "fully-charged" ]]; then
        return 1
      fi
    fi
  elif command -v acpi >/dev/null 2>&1; then
    local acpi_out
    acpi_out=$(acpi -a 2>/dev/null | head -n1 || true)
    if [[ $acpi_out == *"off-line"* ]]; then
      return 0
    fi
    if [[ $acpi_out == *"on-line"* ]]; then
      return 1
    fi
  fi
  return 1
}
