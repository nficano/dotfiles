#!/usr/bin/env bash

# Filesystem utilities inspired by Python's pathlib and shutil modules.
fs.isdir() {
  [[ -d $1 ]]
}
fs.isfile() {
  [[ -f $1 ]]
}
fs.exists() {
  [[ -e $1 ]]
}

fs.file_size_bytes() {
  local path="$1"
  [[ -f $path ]] || return 1
  if stat -f%z "$path" 2>/dev/null; then
    return 0
  fi
  if stat -c%s "$path" 2>/dev/null; then
    return 0
  fi
  wc -c <"$path" 2>/dev/null
}

fs.mkcd() {
  mkdir -p -- "$1" && cd -- "$1" || return 1
}

fs.touchp() {
  mkdir -p -- "$(dirname -- "$1")" && touch -- "$1"
}

fs.mktmp() {
  local type=${1:-file} prefix=${2:-tmp}
  if [[ $type == dir ]]; then
    mktemp -d "${TMPDIR:-/tmp}/${prefix}.XXXXXX"
  else
    mktemp "${TMPDIR:-/tmp}/${prefix}.XXXXXX"
  fi
}

fs.sanitize_filename() {
  local raw="$1" max_len="${2:-255}" ext="${3:-}"
  local cleaned
  cleaned=$(printf '%s' "$raw" | tr '[:upper:]' '[:lower:]' | tr -cs 'a-z0-9' '-')
  cleaned=${cleaned#-}
  cleaned=${cleaned%-}
  [[ -n $cleaned ]] || return 1

  local ext_len="${#ext}"
  local allowed=$((max_len - ext_len))
  ((allowed < 1)) && allowed=1
  if ((${#cleaned} > allowed)); then
    cleaned=${cleaned:0:allowed}
    cleaned=${cleaned%-}
    cleaned=${cleaned#-}
  fi
  [[ -n $cleaned ]] || return 1
  printf '%s\n' "$cleaned"
}

fs.extract() {
  local f="$1"
  [[ -f $f ]] || {
    log.error "No such file: $f"
    return 1
  }
  case "$f" in
  *.tar.bz2) tar xjf "$f" ;;
  *.tar.gz) tar xzf "$f" ;;
  *.tar.xz) tar xJf "$f" ;;
  *.tbz2) tar xjf "$f" ;;
  *.tgz) tar xzf "$f" ;;
  *.zip) unzip -q "$f" ;;
  *.rar) unrar x "$f" ;;
  *.7z) 7z x "$f" ;;
  *)
    log.error "Unknown archive: $f"
    return 2
    ;;
  esac
}

file.expand_globs() {
  local paths_ref_name="$1"
  if ! array._has_var "$paths_ref_name"; then
    return 0
  fi
  eval "local -a paths_ref=(\"\${$paths_ref_name[@]}\")"
  local -a expanded=()

  local previous_nullglob previous_dotglob
  previous_nullglob=$(shopt -p nullglob 2>/dev/null || true)
  previous_dotglob=$(shopt -p dotglob 2>/dev/null || true)
  shopt -s nullglob dotglob

  local path
  for path in "${paths_ref[@]}"; do
    local -a matches=()
    while IFS= read -r match; do
      matches+=("$match")
    done < <(compgen -G "$path" 2>/dev/null || true)

    if [[ ${#matches[@]} -eq 0 ]]; then
      matches+=("$path")
    fi

    expanded+=("${matches[@]}")
  done

  if [[ -n $previous_nullglob ]]; then
    eval "$previous_nullglob"
  fi
  if [[ -n $previous_dotglob ]]; then
    eval "$previous_dotglob"
  fi

  array.empty "$paths_ref_name"
  local value
  for value in "${expanded[@]}"; do
    array.push "$paths_ref_name" "$value"
  done
}

fs.list_files() {
  local dir="$1"
  local include_ref="${2:-}"
  local exclude_ref="${3:-}"
  local -a include=() exclude=()

  if [[ -n $include_ref ]] && array._has_var "$include_ref"; then
    eval "include=(\"\${$include_ref[@]}\")"
  fi
  if [[ -n $exclude_ref ]] && array._has_var "$exclude_ref"; then
    eval "exclude=(\"\${$exclude_ref[@]}\")"
  fi

  local file pattern target include_ok exclude_hit
  while IFS= read -r file; do
    include_ok=1
    if ((${#include[@]})); then
      include_ok=0
      for pattern in "${include[@]}"; do
        target=$(path.pattern_to_glob "$pattern" "$dir")
        if path.match "$file" "$target"; then
          include_ok=1
          break
        fi
      done
    fi

    exclude_hit=0
    if ((include_ok)) && ((${#exclude[@]})); then
      for pattern in "${exclude[@]}"; do
        target=$(path.pattern_to_glob "$pattern" "$dir")
        if path.match "$file" "$target"; then
          exclude_hit=1
          break
        fi
      done
    fi

    if ((include_ok)) && ((exclude_hit == 0)); then
      printf '%s\n' "$file"
    fi
  done < <(find "$dir" -type f -print 2>/dev/null | sort)
}
