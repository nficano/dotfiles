#!/usr/bin/env bash

#
# Core Utility Functions
#
text.substr() {
    echo "${1:$2:$3}"
}

os.devnull() {
    "$@" 2>/dev/null >/dev/null
}

os.setenv() {
    export "${1}"="${2}"
}

os.getenv() {
    env | grep "^$1=" | cut -d'=' -f2
}

#
# System Detection & Path Management
#
sys.platform() {
    uname -s | tr "[:upper:]" "[:lower:]"
}

os.platform.is_darwin() {
    [[ $(sys.platform) == darwin ]]
}

os.platform.is_linux() {
    [[ $(sys.platform) == linux ]]
}

os.path.exists() {
    [[ -f "$1" ]]
}

sys.path.contains() {
    os.devnull command -v "$1"
}

sys.path.prepend() {
    [[ -d "$1" ]] && PATH="$1:${PATH}"
}

#
# Shell Management Functions
#
shell.defer() {
    # Usage:
    #   shell.defer [--wrap] <tool-name> <init-cmd> [args...]
    # Example:
    #   shell.defer "nvm" shell.import "$BREW_PREFIX/opt/nvm/nvm.sh"
    #   shell.defer --wrap gcloud shell.import "$BREW_PREFIX/share/google-cloud-sdk/completion.bash.inc"
    #
    # Creates a stub function named <tool-name>. On first call, it removes
    # itself, runs the initializer, then re-invokes the tool with the
    # original arguments. If the tool already exists, the stub is only
    # installed when --wrap is provided.

    local wrap=0
    if [[ "$1" == "--wrap" || "$1" == "--force" ]]; then
        wrap=1; shift
    fi

    local tool="$1"; shift || true
    if [[ -z "$tool" || $# -lt 1 ]]; then
        log.error "shell.defer usage: shell.defer [--wrap] <tool> <init-cmd> [args...]"
        return 2
    fi

    # Only skip when tool exists and not wrapping
    if (( wrap == 0 )) && command -v "$tool" >/dev/null 2>&1; then
        return 0
    fi

    # Compose initializer invocation to embed into the stub.
    local init_call
    if [[ $# -eq 1 ]]; then
        # Single string initializer; execute via eval for flexibility.
        local cmd_str="$1"
        local q
        printf -v q '%q' "$cmd_str"
        init_call="eval -- $q"
    else
        # Command with separate args; preserve quoting.
        local q
        printf -v q '%q ' "$@"
        init_call="$q"
    fi

    eval "
${tool}() {
  unset -f ${tool} 2>/dev/null
  ${init_call}
  if ! command -v ${tool} >/dev/null 2>&1; then
    echo \"shell.defer: '${tool}' not available after initializer\" >&2
    return 127
  fi
  ${tool} \"\$@\"
}
"
}

shell.setopt() {
    sys.path.contains "shopt" && shopt -s "$1"
}

shell.import() {
    # shellcheck source=/dev/null
    if [[ "$1" == "--defer" ]]; then
        # Usage: shell.import --defer <tool> <file>
        local tool="$2" file="$3"
        if [[ -z "$tool" || -z "$file" ]]; then
            log.error "shell.import --defer <tool> <file>"
            return 2
        fi
        shell.defer "$tool" shell.import "$file"
        return
    fi
    [[ -f "$1" ]] && source "$1"
}

shell.eval() {
    if [[ "$1" == "--defer" ]]; then
        # Usage: shell.eval --defer <tool> "command to eval"
        local tool="$2"; shift 2 || true
        shell.defer "$tool" shell.eval "$1"
        return
    fi
    eval "$($1)"
}

shell.setup_prompt() {
    os.setenv "PS1" "\h \[\e[1;32m\]\$(shell.iterm2_style_path)\[\e[0m\] [\A] > "
}

shell.iterm2_style_path() {
    # Mimic iTerm2's absolute path abbreviation. For example,
    # "/usr/local/bin" abbreviates to "/u/l/bin".
    IFS="/"
    read -ra relpath <<<"$(dirs +0)"
    buffer=""
    dirname=$((${#relpath[*]} - 1))

    for folder_name in "${relpath[@]}"; do
        if [[ $folder_name != "${relpath[$dirname]}" ]]; then
            buffer+="$(text.substr "$folder_name" 0 1)/"
        fi
    done
    echo -n "$buffer${folder_name}"
}

#
# SSH Agent Management
#
ssh_agent.active_sessions() {
    pgrep -u "$USER" ssh-agent
}

ssh_agent.start() {
    [[ -z "$1" ]] && return 1
    os.devnull rm "$1"
    ssh-agent | sed "s/^echo/#echo/" >"$1"
    chmod 600 "$1"
    shell.import "$1"
}

ssh_agent.init() {
    local env="$1"
    [[ -z "$env" ]] && return 1

    touch "$env"
    if ! os.devnull ssh_agent.active_sessions; then
        ssh_agent.start "$env"
    else
        shell.import "$env"
    fi

    if ! os.devnull ssh-add -l; then
        os.devnull ssh-add -k
    fi
}

#
# Homebrew Functions
#
brew.prefix() {
    # Memoized Homebrew prefix detection
    if [[ -n "${_BREW_PREFIX:-}" ]]; then
        echo "$_BREW_PREFIX"
        return 0
    fi
    if os.path.exists /opt/homebrew/bin/brew; then
        _BREW_PREFIX=/opt/homebrew
    elif os.path.exists /usr/local/bin/brew; then
        _BREW_PREFIX=/usr/local
    else
        _BREW_PREFIX=""
    fi
    echo "$_BREW_PREFIX"
}

#
# Higher-level convenience APIs
#

# --- Conditional runners ---------------------------------------------------
when.cmd() { # when.cmd <command> <then...>
    local c="$1"; shift || true
    command -v "$c" >/dev/null 2>&1 || return 1
    if (($# == 0)); then
        return 0
    elif (($# == 1)); then
        eval "$1"
    else
        "$@"
    fi
}
when.not_cmd() { # when.not_cmd <command> <then...>
    local c="$1"; shift || true
    command -v "$c" >/dev/null 2>&1 && return 1
    if (($# == 0)); then
        return 0
    elif (($# == 1)); then
        eval "$1"
    else
        "$@"
    fi
}
when.darwin() {
    os.platform.is_darwin || return 1
    "$@"
}
when.linux() {
    os.platform.is_linux || return 1
    "$@"
}

# --- PATH helpers ----------------------------------------------------------
sys.path.append() {
    [[ -d "$1" ]] && PATH="${PATH}:$1"
}
sys.path.prepend_many() { # pass directories as args
    local d
    for d in "$@"; do sys.path.prepend "$d"; done
}
sys.path.append_many() { # pass directories as args
    local d
    for d in "$@"; do sys.path.append "$d"; done
}

# --- Alias helpers ---------------------------------------------------------
alias.setup_ls() {
    # Portable, colored ls + ll aliases across platforms.
    if os.platform.is_linux; then
        alias ls='ls --color=auto -gXF'
        alias ll='ls --color=auto -algX'
    else
        if sys.path.contains gls; then
            alias ls='gls --color=auto -gXF'
            alias ll='gls --color=auto -algX'
        else
            alias ls='ls -GF'
            alias ll='ls -alG'
        fi
    fi
}

# --- Simple cache ----------------------------------------------------------
cache.dir() {
    local base="${XDG_CACHE_HOME:-$HOME/.cache}/dotfiles"
    mkdir -p "$base"
    echo "$base"
}

cache.path_for() { # cache.path_for <key>
    local key="$1"
    echo "$(cache.dir)/$(echo "$key" | tr '/ ' '__')"
}

cache.get() { # cache.get <key> <ttl-seconds>
    local key="$1" ttl=${2:-0}
    local f
    f=$(cache.path_for "$key")
    [[ -f $f ]] || return 1
    if (( ttl > 0 )); then
        local now=$(date +%s) mtime=$(stat -f %m "$f" 2>/dev/null || stat -c %Y "$f" 2>/dev/null || echo 0)
        (( now - mtime <= ttl )) || return 1
    fi
    cat "$f"
}

cache.set() { # cache.set <key> <data-from-stdin>
    local key="$1" f
    f=$(cache.path_for "$key")
    cat - >"$f"
}

shell.eval_cached() { # shell.eval_cached <key> <ttl> <cmd string>
    local key="$1" ttl="$2" cmd="$3"
    local data
    if data=$(cache.get "$key" "$ttl" 2>/dev/null); then
        eval "$data"
        return
    fi
    data="$($cmd)"
    printf "%s" "$data" | cache.set "$key"
    eval "$data"
}

# --- State capture ---------------------------------------------------------
state._dump_env() { env | sort; }
state._dump_shopt() { shopt -p 2>/dev/null | sort; }
state._dump_seto() { set -o | sort; }
state._dump_aliases() { alias -p | sort; }
state._dump_functions() { declare -F | awk '{print $3}' | sort; }
state._dump_path() { tr ':' '\n' <<<"$PATH"; }
state._dump_completions() { complete -p 2>/dev/null | sort; }

state.capture_begin() { # state.capture_begin <name>
    local name=${1:-session}
    local base="$(cache.dir)/state/${name}/pre"
    mkdir -p "$base"
    state._dump_env >"$base/env"
    state._dump_shopt >"$base/shopt"
    state._dump_seto >"$base/seto"
    state._dump_aliases >"$base/aliases"
    state._dump_functions >"$base/functions"
    state._dump_path >"$base/path"
    state._dump_completions >"$base/completions"
    export STATE_CAPTURE_NAME="$name"
}

state.capture_end() { # state.capture_end [name]
    local name="${1:-${STATE_CAPTURE_NAME:-session}}"
    local pre="$(cache.dir)/state/${name}/pre"
    local post="$(cache.dir)/state/${name}/post"
    mkdir -p "$post"
    state._dump_env >"$post/env"
    state._dump_shopt >"$post/shopt"
    state._dump_seto >"$post/seto"
    state._dump_aliases >"$post/aliases"
    state._dump_functions >"$post/functions"
    state._dump_path >"$post/path"
    state._dump_completions >"$post/completions"
    if command -v diff >/dev/null 2>&1; then
        diff -ru "$pre" "$post" >"$(cache.dir)/state/${name}/diff.txt" || true
    fi
}

#
# Additional Utility Functions
#

# --- Logging ---------------------------------------------------------------
log._color() { # $1=color_code
    echo "\e[${1}m"
}
log._reset() { echo "\e[0m"; }
log.info()  { printf "$(log._color 1; log._color 34)[INFO]$(log._reset) %s\n" "$*"; }
log.warn()  { printf "$(log._color 1; log._color 33)[WARN]$(log._reset) %s\n" "$*"; }
log.error() { printf "$(log._color 1; log._color 31)[ERR ]$(log._reset) %s\n" "$*"; }

# --- Preconditions ---------------------------------------------------------
require.cmd() { # fail if any command is missing
    local missing=0
    for c in "$@"; do
        if ! sys.path.contains "$c"; then
            log.error "Required command not found: $c"
            missing=1
        fi
    done
    (( missing == 0 ))
}

confirm.yesno() { # $1=prompt ; returns 0 for yes
    local prompt=${1:-"Proceed?"}
    read -r -p "$prompt [y/N] " reply
    [[ $reply =~ ^[Yy]([Ee][Ss])?$ ]]
}

# --- Enhanced Prompting System -----------------------------------------------
prompt.ask_yes_no() { # prompt.ask_yes_no <prompt> [assume_yes] [non_interactive] [verbose]
    local prompt="$1"
    local assume_yes="${2:-0}"
    local non_interactive="${3:-0}"
    local verbose="${4:-0}"

    if (( assume_yes )); then
        (( verbose )) && printf 'Assuming yes: %s\n' "$prompt"
        return 0
    fi

    if (( non_interactive )); then
        log.error "Cannot prompt in non-interactive mode ($prompt)"
        return 1
    fi

    local reply=""
    read -r -p "$prompt [y/N]: " reply
    case "$reply" in
        [Yy]*) return 0 ;;
        *) return 1 ;;
    esac
}

prompt.read_input() { # prompt.read_input <prompt> [default] [non_interactive] [env_var]
    local prompt="$1"
    local default="${2:-}"
    local non_interactive="${3:-0}"
    local env_var="${4:-}"

    if (( non_interactive )); then
        if [[ -n "$env_var" ]]; then
            echo "${!env_var:-$default}"
        else
            echo "$default"
        fi
        return
    fi

    local input=""
    if [[ -n "$default" ]]; then
        read -r -p "$prompt [$default]: " input
        echo "${input:-$default}"
    else
        read -r -p "$prompt: " input
        echo "$input"
    fi
}

prompt.read_required() { # prompt.read_required <prompt> [non_interactive] [env_var]
    local prompt="$1"
    local non_interactive="${2:-0}"
    local env_var="${3:-}"

    local input
    input=$(prompt.read_input "$prompt" "" "$non_interactive" "$env_var")

    if [[ -z "$input" ]]; then
        log.error "Input value must not be empty"
        return 1
    fi

    echo "$input"
}

retry() { # retry N times with backoff; usage: retry 5 2 "cmd arg1 arg2"
    local tries=${1:-3} sleep_s=${2:-1} cmd=${3}
    local n=0
    until eval "$cmd"; do
        (( n++ >= tries )) && return 1
        sleep $(( sleep_s * n ))
    done
}

# --- Filesystem ------------------------------------------------------------
fs.isdir() { [[ -d "$1" ]]; }
fs.isfile() { [[ -f "$1" ]]; }
fs.exists() { [[ -e "$1" ]]; }

fs.mkcd() { # make dir and cd into it
    mkdir -p -- "$1" && cd -- "$1" || return 1
}

fs.touchp() { # ensure parent dir exists then touch
    mkdir -p -- "$(dirname -- "$1")" && touch -- "$1"
}

fs.mktmp() { # create temp file/dir; usage: fs.mktmp [dir|file] [prefix]
    local type=${1:-file} prefix=${2:-tmp}
    if [[ $type == dir ]]; then
        mktemp -d "${TMPDIR:-/tmp}/${prefix}.XXXXXX"
    else
        mktemp "${TMPDIR:-/tmp}/${prefix}.XXXXXX"
    fi
}

fs.extract() { # extract archives of common types to CWD
    local f="$1"
    [[ -f $f ]] || { log.error "No such file: $f"; return 1; }
    case "$f" in
        *.tar.bz2)   tar xjf "$f" ;;
        *.tar.gz)    tar xzf "$f" ;;
        *.tar.xz)    tar xJf "$f" ;;
        *.tbz2)      tar xjf "$f" ;;
        *.tgz)       tar xzf "$f" ;;
        *.zip)       unzip -q "$f" ;;
        *.rar)       unrar x "$f" ;;
        *.7z)        7z x "$f" ;;
        *)           log.error "Unknown archive: $f"; return 2 ;;
    esac
}

# --- Strings ---------------------------------------------------------------
str.trim() { local s="$*"; s="${s%%[[:space:]]*}"; s="${s##*[[:space:]]}"; echo "$s"; }
str.lower() { tr '[:upper:]' '[:lower:]'; }
str.upper() { tr '[:lower:]' '[:upper:]'; }

str.urlencode() { # minimal RFC 3986
    local LC_ALL=C
    local s="$*"
    local i c out=""
    for (( i=0; i<${#s}; i++ )); do
        c=${s:i:1}
        case "$c" in
            [a-zA-Z0-9._~-]) out+="$c" ;;
            ' ') out+='%20' ;;
            *) printf -v out '%s%%%02X' "$out" "'"$c ;;
        esac
    done
    echo "$out"
}

str.urldecode() {
    : "${*//+/ }"; echo -e "${_//%/\\x}"
}

# --- Time ------------------------------------------------------------------
time.epoch()   { date +%s; }
time.iso8601() { date -u +%Y-%m-%dT%H:%M:%SZ; }

# --- Clipboard -------------------------------------------------------------
clip.copy() {
    if os.platform.is_darwin; then pbcopy; else xclip -selection clipboard; fi
}
clip.paste() {
    if os.platform.is_darwin; then pbpaste; else xclip -selection clipboard -o; fi
}

# --- Script Framework ------------------------------------------------------
script.usage() { # script.usage [exit_code]
    local exit_code="${1:-0}"
    grep '^#/' < "${BASH_SOURCE[1]}" | cut -c4-
    exit "$exit_code"
}

script.cleanup() { # script.cleanup - basic cleanup function
    trap - SIGINT SIGTERM ERR EXIT
}

script.parse_common() { # script.parse_common <args...> - parse common options (h, v, help, verbose)
    local opt
    local -a transformed=()

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --help) transformed+=('-h') ;;
            --verbose) transformed+=('-v') ;;
            --)
                shift
                break
                ;;
            --*)
                log.error "Unknown option: $1"
                script.usage 1
                ;;
            *)
                break
                ;;
        esac
        shift
    done

    transformed+=("$@")
    set -- "${transformed[@]}"

    while getopts ':hv' opt; do
        case "$opt" in
            h) script.usage ;;
            v) verbose=1 ;;
            \?) log.error "Invalid option: -$OPTARG"; script.usage 1 ;;
        esac
    done

    shift $((OPTIND - 1))
    echo "$@"
}

script.validate_positive_int() { # script.validate_positive_int <value> <name>
    local value="$1" name="$2"
    if ! [[ $value =~ ^[0-9]+$ ]] || [[ $value -le 0 ]]; then
        log.error "$name must be a positive integer"
        script.usage 1
    fi
}

script.require_args() { # script.require_args <count> <description>
    local count="$1" description="$2"
    if [[ $# -lt $((count + 2)) ]]; then
        log.error "Missing required $description"
        script.usage 1
    fi
}

# --- Lock Management -------------------------------------------------------
lock.acquire() { # lock.acquire <lock_name> [verbose]
    local lock_name="$1" verbose="${2:-0}"
    local lock_file="${TMPDIR:-/tmp}/${lock_name}.lock"
    local lock_fd=-1

    if ! eval "exec {lock_fd}>\"$lock_file\""; then
        log.error "Cannot open lock file $lock_file"
        return 1
    fi

    if ! flock -n "$lock_fd"; then
        (( verbose )) && log.warn "Another instance is already running (lock: $lock_file)"
        eval "exec ${lock_fd}>&-"
        return 1
    fi

    (( verbose )) && log.info "Acquired lock $lock_file"
    echo "$lock_fd:$lock_file"
}

lock.release() { # lock.release <lock_fd:lock_file>
    local lock_spec="$1"
    local lock_fd="${lock_spec%%:*}"
    local lock_file="${lock_spec#*:}"

    if [[ $lock_fd -ne -1 ]]; then
        flock -u "$lock_fd" 2>/dev/null || true
        eval "exec ${lock_fd}>&-" 2>/dev/null || true
    fi

    if [[ -n "$lock_file" ]]; then
        rm -f -- "$lock_file"
    fi
}

# --- Process Management ----------------------------------------------------
proc.cpu_count() { # proc.cpu_count - get CPU count with fallback
    local count=4
    if command -v getconf >/dev/null 2>&1; then
        count=$(getconf _NPROCESSORS_ONLN 2>/dev/null || echo 4)
    fi
    if ! [[ $count =~ ^[0-9]+$ ]] || [[ $count -le 0 ]]; then
        count=4
    fi
    echo "$count"
}

proc.wait_for_pids() { # proc.wait_for_pids <pids_array> [had_failure_ref]
    local -n pids_ref="$1"
    local had_failure_ref="${2:-}"
    local had_failure=0

    for pid in "${pids_ref[@]}"; do
        if kill -0 "$pid" 2>/dev/null; then
            if ! wait "$pid"; then
                had_failure=1
            fi
        fi
    done

    if [[ -n "$had_failure_ref" ]]; then
        printf -v "$had_failure_ref" "%d" "$had_failure"
    fi

    pids_ref=()
}

# --- File Processing -------------------------------------------------------
file.expand_globs() { # file.expand_globs <paths_array> - expand glob patterns
    local -n paths_ref="$1"
    local -a expanded=()

    local previous_nullglob previous_dotglob
    previous_nullglob=$(shopt -p nullglob 2>/dev/null || true)
    previous_dotglob=$(shopt -p dotglob 2>/dev/null || true)
    shopt -s nullglob dotglob

    for path in "${paths_ref[@]}"; do
        local -a matches=()
        while IFS= read -r match; do
            matches+=("$match")
        done < <(compgen -G "$path" 2>/dev/null || true)

        if [[ ${#matches[@]} -eq 0 ]]; then
            matches+=("$path")
        fi

        expanded+=("${matches[@]}")
    done

    # Restore shell options
    if [[ -n "$previous_nullglob" ]]; then
        eval "$previous_nullglob"
    fi
    if [[ -n "$previous_dotglob" ]]; then
        eval "$previous_dotglob"
    fi

    paths_ref=("${expanded[@]}")
}
