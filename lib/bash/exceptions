#!/usr/bin/env bash

# exceptions â€” Python-inspired exception taxonomy and helpers for Bash.
# Provides structured error codes, formatted output, and lightweight guard
# utilities for shell scripts.

# Maintain the exception registry using indexed arrays so the module remains
# compatible with the macOS system Bash (3.2).
exception._ensure_registry() {
  if [[ -n ${ERR_CODE_REGISTRY_INIT:-} ]]; then
    return
  fi
  ERR_CODE_REGISTRY_INIT=1
  ERR_CODE_NAMES=(
    BaseException
    SystemExit
    Exception
    AssertionError
    AttributeError
    EOFError
    ImportError
    ModuleNotFoundError
    LookupError
    IndexError
    KeyError
    MemoryError
    NameError
    UnboundLocalError
    ReferenceError
    RuntimeError
    NotImplementedError
    RecursionError
    StopIteration
    StopAsyncIteration
    SyntaxError
    IndentationError
    TabError
    TypeError
    ValueError
    SystemError
    BufferError
    ArithmeticError
    ZeroDivisionError
    OverflowError
    FloatingPointError
    OSError
    BlockingIOError
    ChildProcessError
    ConnectionError
    BrokenPipeError
    ConnectionAbortedError
    ConnectionRefusedError
    ConnectionResetError
    FileExistsError
    FileNotFoundError
    InterruptedError
    IsADirectoryError
    NotADirectoryError
    PermissionError
    ProcessLookupError
    TimeoutError
    UnicodeError
    UnicodeEncodeError
    UnicodeDecodeError
    UnicodeTranslateError
  )

  ERR_CODE_VALUES=(
    100
    101
    110
    111
    112
    113
    114
    115
    116
    117
    118
    119
    120
    121
    122
    123
    124
    125
    126
    127
    128
    129
    130
    131
    132
    133
    134
    140
    141
    142
    143
    150
    151
    152
    153
    154
    155
    156
    157
    158
    159
    160
    161
    162
    163
    164
    165
    170
    171
    172
    173
  )
}

exception._ensure_registry

exception._find_index_by_name() {
  exception._ensure_registry
  local target="$1"
  local i count
  count=${#ERR_CODE_NAMES[@]}
  for ((i = 0; i < count; i++)); do
    if [[ ${ERR_CODE_NAMES[i]} == "$target" ]]; then
      printf '%s\n' "$i"
      return 0
    fi
  done
  return 1
}

exception._find_index_by_code() {
  exception._ensure_registry
  local target="$1"
  local i count
  count=${#ERR_CODE_VALUES[@]}
  for ((i = 0; i < count; i++)); do
    if [[ ${ERR_CODE_VALUES[i]} == "$target" ]]; then
      printf '%s\n' "$i"
      return 0
    fi
  done
  return 1
}

exception.exists() {
  exception._find_index_by_name "$1" >/dev/null
}

: "${ERR_STRATEGY:=return}" # return | exit
: "${ERR_PREFIX:=ERROR}"    # prefix label
: "${ERR_TRACE:=1}"         # include file:line context

exception._timestamp() {
  date +%Y-%m-%dT%H:%M:%S%z
}

exception._call_site() {
  local depth="${1:-2}"
  local src line fn
  read -r src line fn < <(caller "$depth" || true)
  printf ' [%s:%s %s]' "${src:-?}" "${line:-?}" "${fn:-main}"
}

# exception.register Name Code
# Extends the taxonomy while keeping reverse lookups in sync.
exception.register() {
  if (($# != 2)); then
    printf 'exception.register requires Name and Code\n' >&2
    return 2
  fi
  local name="$1" code="$2" idx
  if idx=$(exception._find_index_by_name "$name"); then
    ERR_CODE_VALUES[idx]="$code"
  else
    ERR_CODE_NAMES+=("$name")
    ERR_CODE_VALUES+=("$code")
  fi
}

exception.code() { # Name -> numeric code
  local name="$1" idx
  if idx=$(exception._find_index_by_name "$name"); then
    printf '%s\n' "${ERR_CODE_VALUES[idx]}"
  else
    printf '110\n'
  fi
}

exception.name() { # Code -> Name
  local code="$1" idx
  if idx=$(exception._find_index_by_code "$code"); then
    printf '%s\n' "${ERR_CODE_NAMES[idx]}"
  else
    printf 'Exception\n'
  fi
}

exception.format() { # Name "message" [code]
  local name="$1" message="$2" code="${3:-$(exception.code "$1")}"
  local where=""
  if [[ ${ERR_TRACE:-1} -eq 1 ]]; then
    where="$(exception._call_site 3)"
  fi
  printf '%s %s %s: %s (code=%s)%s\n' \
    "$(exception._timestamp)" "${ERR_PREFIX}" "$name" "${message:-}" "$code" "$where" >&2
}

# exception.raise Name ["message"]
# Obeys ERR_STRATEGY: return (default) or exit.
exception.raise() {
  if (($# == 0)); then
    printf 'exception.raise requires a Name argument\n' >&2
    return 2
  fi
  local name="$1"
  shift || true
  local message="${*:-}"
  local code
  code="$(exception.code "$name")"
  exception.format "$name" "$message" "$code"
  if [[ ${ERR_STRATEGY} == "exit" ]]; then
    exit "$code"
  fi
  return "$code"
}

# exception.wrap Name "message fmt" [fmt-args ...] -- command [arg...]
exception.wrap() {
  if (($# < 2)); then
    exception.raise ValueError "exception.wrap requires an exception name and message"
  fi
  local name="$1"
  shift
  local format="$1"
  shift

  local -a fmt_args=()
  while (($#)); do
    if [[ $1 == "--" ]]; then
      shift
      break
    fi
    fmt_args+=("$1")
    shift
  done

  local message="$format"
  if ((${#fmt_args[@]})); then
    printf -v message "$format" "${fmt_args[@]}"
  fi

  if (($# == 0)); then
    exception.raise ValueError "exception.wrap requires a command after --"
  fi

  "$@" || exception.raise "$name" "$message"
}

# exception.try <cmd...> || exception.as Name "message"
exception.try() {
  "$@"
}

exception.as() {
  if (($# < 1)); then
    exception.raise ValueError "exception.as requires an exception name"
  fi
  local name="$1"
  shift || true
  local message="${*:-wrapped failure}"
  exception.raise "$name" "$message"
}

: "${exception__depth:=0}"
: "${exception__oldopts:=}"

# trap-based pretty printer for unhandled nonzero exits inside a guarded block.
# Usage:
#   exception.guard begin
#   ... your code ...
#   exception.guard end
exception.guard() {
  if (($# != 1)); then
    exception.raise ValueError "usage: exception.guard begin|end"
  fi
  case "$1" in
  begin)
    ((exception__depth++))
    if ((exception__depth == 1)); then
      exception__oldopts="$-"
      set -E -o pipefail
      trap 'rc=$?; if (( rc != 0 )); then
        exception.format "$(exception.name "$rc")" "unhandled exit status" "$rc"
        return "$rc" 2>/dev/null || exit "$rc"
      fi' ERR
    fi
    ;;
  end)
    if ((exception__depth == 0)); then
      exception.raise RuntimeError "exception.guard end without begin"
    fi
    ((exception__depth--))
    if ((exception__depth == 0)); then
      trap - ERR
      [[ $exception__oldopts == *e* ]] || set +e
      exception__oldopts=""
    fi
    ;;
  *)
    exception.raise ValueError "usage: exception.guard begin|end"
    ;;
  esac
}
