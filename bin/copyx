#!/usr/bin/env bash
#/ Execute hourly incremental rsync backups based on a YAML configuration.
#/
#/ Usage: $(basename "$0") [-h] [-v] [-n] [-i seconds] [--config path] [--oneshot]
#/
#/ Available options:
#/    -h, --help        Print this help and exit
#/    -v, --verbose     Enable verbose output
#/    -n, --dry-run     Run rsync in dry-run mode
#/    -i, --interval    Seconds between iterations (default 3600)
#/        --config      Path to YAML config (or COPYX_CONFIG env var)
#/        --oneshot     Run a single iteration then exit
#/        --launchd-load    Write LaunchAgent plist and load via launchctl
#/        --launchd-unload  Unload LaunchAgent via launchctl
#/
#/ Examples:
#/    $(basename "$0") --config ~/.config/copyx.yml
#/    COPYX_CONFIG=~/.config/copyx.yml $(basename "$0") --oneshot
#/
#/ Config keys:
#/    backup_root   Destination directory for synced data
#/    machine_id    Optional machine identifier (hostname used if omitted)
#/    sources       List of paths/globs to replicate
#/    exclude       Optional list of rsync exclude patterns

set -Eeuo pipefail
trap 'should_exit=1; cleanup' SIGINT SIGTERM
trap cleanup ERR EXIT

source "$(dirname "$0")/../lib/bash/initrc"

verbose=0
dry_run=0
interval=3600
oneshot=0
should_exit=0
config_path="${COPYX_CONFIG:-}"
launchd_action=""

readonly LAUNCHD_LABEL="com.nficano.copyx"
readonly LAUNCHD_PATH_VALUE="/usr/local/bin:/opt/homebrew/bin:/usr/bin:/bin:/usr/sbin:/sbin"

config_dir=""
config_backup_root=""
config_machine_id=""
config_sources=()
config_exclude_patterns=()
expanded_sources=()

expand_env_placeholders() {
  local value="$1"
  if [[ -z "$value" ]]; then
    printf '%s\n' "$value"
    return
  fi
  if [[ "$value" == *'${HOME}'* ]]; then
    value="${value//\$\{HOME\}/$HOME}"
  fi
  if [[ "$value" == *'$HOME'* ]]; then
    value="${value//\$HOME/$HOME}"
  fi
  printf '%s\n' "$value"
}

config_pattern_to_glob() {
  local pattern="$1"
  pattern=$(expand_env_placeholders "$pattern")
  if [[ -n "$pattern" && ${pattern:0:1} == '~' ]]; then
    case "$pattern" in
      "~") pattern="$HOME" ;;
      ~/*) pattern="$HOME/${pattern:2}" ;;
    esac
  elif [[ "$pattern" != /* ]]; then
    pattern="$config_dir/$pattern"
  fi
  printf '%s\n' "$pattern"
}

xml_escape() {
  local value="$1"
  value="${value//&/&amp;}"
  value="${value//</&lt;}"
  value="${value//>/&gt;}"
  value="${value//\"/&quot;}"
  value="${value//\'/&apos;}"
  printf '%s\n' "$value"
}

cleanup() {
  script.cleanup
}

trim() {
  local s=""
  if (( $# )); then
    s="$1"
  else
    s=$(cat)
  fi
  s="${s#"${s%%[![:space:]]*}"}"
  s="${s%"${s##*[![:space:]]}"}"
  printf '%s' "$s"
}

resolve_path() {
  local path="$1" base_dir="${2:-$PWD}"
  path=$(expand_env_placeholders "$path")
  if [[ -n "$path" && ${path:0:1} == '~' ]]; then
    case "$path" in
      "~") path="$HOME" ;;
      ~/*) path="$HOME/${path:2}" ;;
    esac
  fi
  if [[ -n "$base_dir" && "$path" != /* ]]; then
    path="$base_dir/$path"
  fi
  if command -v realpath >/dev/null 2>&1; then
    realpath "$path" 2>/dev/null || printf '%s\n' "$path"
    return
  fi
  local dir part
  dir=$(dirname -- "$path")
  part=$(basename -- "$path")
  (
    cd "$dir" 2>/dev/null && printf '%s/%s\n' "$(pwd)" "$part"
  ) || printf '%s\n' "$path"
}

relative_dest_path() {
  local path="$1" home_name
  while [[ "$path" != "/" && "${path: -1}" == "/" ]]; do
    path="${path%/}"
  done
  if [[ -n "$HOME" && "$path" == "$HOME"* ]]; then
    home_name=$(basename -- "$HOME")
    local rest="${path#"$HOME"}"
    rest="${rest#/}"
    if [[ -n "$rest" ]]; then
      printf 'home/%s/%s\n' "$home_name" "$rest"
    else
      printf 'home/%s\n' "$home_name"
    fi
    return
  fi
  path="${path#/}"
  if [[ -z "$path" ]]; then
    printf 'root\n'
  else
    printf '%s\n' "$path"
  fi
}

resolve_machine_id() {
  if [[ -n "$config_machine_id" ]]; then
    return
  fi

  local machine_id_file="$HOME/.machine_id"
  local candidate=""

  if os.machine_id.matches_current; then
    if [[ -f "$machine_id_file" ]]; then
      candidate=$(<"$machine_id_file")
      candidate=$(trim "$candidate")
    fi
    if [[ -n "$candidate" ]]; then
      config_machine_id="$candidate"
      log.info "Using machine identifier from $machine_id_file"
      return
    fi
    log.info "Machine identifier lookup returned empty result; falling back to hostname"
  fi

  config_machine_id=$(hostname -s 2>/dev/null || hostname)
  config_machine_id=$(trim "$config_machine_id")
  log.info "Config did not specify 'machine_id'; using hostname '$config_machine_id'"
}

launchd_domain() {
  printf 'gui/%s\n' "$(id -u)"
}

launchd_plist_path() {
  printf '%s/Library/LaunchAgents/%s.plist\n' "$HOME" "$LAUNCHD_LABEL"
}

launchd_logs_dir() {
  printf '%s/Library/Logs/copyx\n' "$HOME"
}

launchd_prepare_plist() {
  local config_file="$1" start_interval="$2"
  local plist_path log_dir script_path script_source script_dir
  plist_path=$(launchd_plist_path)
  log_dir=$(launchd_logs_dir)
  script_source="${BASH_SOURCE[0]}"
  script_dir=$(cd "$(dirname -- "$script_source")" && pwd -P)
  script_path=$(resolve_path "$(basename -- "$script_source")" "$script_dir")

  local script_xml config_xml path_xml stdout_xml stderr_xml stdout_path stderr_path
  script_xml=$(xml_escape "$script_path")
  config_xml=$(xml_escape "$config_file")
  path_xml=$(xml_escape "$LAUNCHD_PATH_VALUE")
  stdout_path="$log_dir/stdout.log"
  stderr_path="$log_dir/stderr.log"
  stdout_xml=$(xml_escape "$stdout_path")
  stderr_xml=$(xml_escape "$stderr_path")

  mkdir -p "$(dirname "$plist_path")" "$log_dir"

  cat >"$plist_path" <<EOF
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>Label</key>
    <string>${LAUNCHD_LABEL}</string>
    <key>ProgramArguments</key>
    <array>
        <string>${script_xml}</string>
        <string>--config</string>
        <string>${config_xml}</string>
        <string>--oneshot</string>
    </array>
    <key>EnvironmentVariables</key>
    <dict>
        <key>PATH</key>
        <string>${path_xml}</string>
    </dict>
    <key>StartInterval</key>
    <integer>${start_interval}</integer>
    <key>RunAtLoad</key>
    <true/>
    <key>StandardOutPath</key>
    <string>${stdout_xml}</string>
    <key>StandardErrorPath</key>
    <string>${stderr_xml}</string>
</dict>
</plist>
EOF

  chmod 0644 "$plist_path"

  if command -v plutil >/dev/null 2>&1; then
    if ! plutil -lint "$plist_path" >/dev/null 2>&1; then
      log.warn "plutil validation failed for $plist_path"
    fi
  fi

  printf '%s\n' "$plist_path"
}

launchd_handle_load() {
  if ! command -v launchctl >/dev/null 2>&1; then
    log.error "launchctl is required to manage LaunchAgents"
    exit 1
  fi

  local config="${config_path:-}"
  if [[ -z "$config" ]]; then
    config="$HOME/.config/copyx/config.yml"
    log.info "No config provided; defaulting to $config"
  fi

  config=$(resolve_path "$config" "$PWD")

  if [[ ! -f "$config" ]]; then
    log.error "Config path not found: $config"
    exit 1
  fi

  config_path="$config"

  local plist_path
  plist_path=$(launchd_prepare_plist "$config" "$interval")

  local domain
  domain=$(launchd_domain)

  if launchctl print "$domain/$LAUNCHD_LABEL" >/dev/null 2>&1; then
    if launchctl bootout "$domain" "$plist_path" >/dev/null 2>&1; then
      (( verbose )) && log.info "Unloaded existing LaunchAgent $LAUNCHD_LABEL"
    else
      log.warn "Failed to unload existing LaunchAgent $LAUNCHD_LABEL; attempting to continue"
    fi
  fi

  if ! launchctl bootstrap "$domain" "$plist_path"; then
    log.error "launchctl bootstrap failed for $plist_path"
    exit 1
  fi

  launchctl enable "$domain/$LAUNCHD_LABEL" >/dev/null 2>&1 || true

  if launchctl kickstart -k "$domain/$LAUNCHD_LABEL" >/dev/null 2>&1; then
    (( verbose )) && log.info "LaunchAgent $LAUNCHD_LABEL started"
  else
    log.warn "launchctl kickstart failed; agent will start on the next scheduled interval"
  fi

  log.info "LaunchAgent $LAUNCHD_LABEL loaded from $plist_path"
  return 0
}

launchd_handle_unload() {
  if ! command -v launchctl >/dev/null 2>&1; then
    log.error "launchctl is required to manage LaunchAgents"
    exit 1
  fi

  local plist_path
  plist_path=$(launchd_plist_path)

  local domain
  domain=$(launchd_domain)

  if launchctl print "$domain/$LAUNCHD_LABEL" >/dev/null 2>&1; then
    if launchctl bootout "$domain" "$plist_path" >/dev/null 2>&1; then
      log.info "LaunchAgent $LAUNCHD_LABEL unloaded"
    elif launchctl bootout "$domain/$LAUNCHD_LABEL" >/dev/null 2>&1; then
      log.info "LaunchAgent $LAUNCHD_LABEL unloaded"
    else
      log.error "Failed to unload LaunchAgent $LAUNCHD_LABEL"
      exit 1
    fi
  else
    log.info "LaunchAgent $LAUNCHD_LABEL not currently loaded"
  fi

  launchctl disable "$domain/$LAUNCHD_LABEL" >/dev/null 2>&1 || true

  if [[ -f "$plist_path" ]]; then
    if (( verbose )); then
      log.info "LaunchAgent plist remains at $plist_path"
    fi
  else
    log.warn "LaunchAgent plist not found at $plist_path"
  fi
  return 0
}

ensure_prerequisites() {
  if ! command -v rsync >/dev/null 2>&1; then
    log.error "rsync is required but not found in PATH"
    exit 1
  fi
  if ! command -v yq >/dev/null 2>&1; then
    log.error "yq is required but not found in PATH"
    exit 1
  fi
}

load_config() {
  local file="$1"
  [[ -f "$file" ]] || { log.error "Config file not found: $file"; return 1; }

  config_dir=$(cd "$(dirname -- "$file")" && pwd -P)
  config_backup_root=$(trim "$(yq eval -r '.backup_root // ""' "$file" 2>/dev/null)")
  config_backup_root=$(expand_env_placeholders "$config_backup_root")
  config_machine_id=$(trim "$(yq eval -r '.machine_id // ""' "$file" 2>/dev/null)")
  config_machine_id=$(expand_env_placeholders "$config_machine_id")
  config_sources=()
  config_exclude_patterns=()

  local sources_raw=""
  if ! sources_raw=$(yq eval -r '.sources // [] | .[]' "$file" 2>/dev/null); then
    log.error "Failed to parse 'sources' from config via yq"
    return 1
  fi

  local item
  if [[ -n "$sources_raw" ]]; then
    while IFS= read -r item || [[ -n "$item" ]]; do
      item=$(trim "$item")
      [[ -n "$item" ]] && config_sources+=("$(expand_env_placeholders "$item")")
    done <<<"$sources_raw"
  fi

  local exclude_raw=""
  if ! exclude_raw=$(yq eval -r '.exclude // [] | .[]' "$file" 2>/dev/null); then
    log.error "Failed to parse 'exclude' from config via yq"
    return 1
  fi

  if [[ -n "$exclude_raw" ]]; then
    while IFS= read -r item || [[ -n "$item" ]]; do
      item=$(trim "$item")
      [[ -n "$item" ]] && config_exclude_patterns+=("$(expand_env_placeholders "$item")")
    done <<<"$exclude_raw"
  fi

  if [[ -z "$config_backup_root" ]]; then
    log.error "Config missing required 'backup_root'"
    return 1
  fi

  resolve_machine_id
}

expand_sources() {
  expanded_sources=()
  local -a patterns=("${config_sources[@]}")
  if [[ ${#patterns[@]} -eq 0 ]]; then
    return
  fi

  local pattern prepared
  for pattern in "${patterns[@]}"; do
    prepared=$(config_pattern_to_glob "$pattern")
    local -a matches=()
    while IFS= read -r match; do
      matches+=("$match")
    done < <(compgen -G "$prepared" 2>/dev/null || true)
    if [[ ${#matches[@]} -eq 0 ]]; then
      matches+=("$prepared")
    fi
    local match resolved
    for match in "${matches[@]}"; do
      if [[ -d "$match" || -f "$match" ]]; then
        resolved=$(resolve_path "$match")
        expanded_sources+=("$resolved")
      else
        log.warn "Source not found: $pattern (resolved to $match)"
      fi
    done
  done
}

perform_backup_iteration() {
  local config_file="$1"
  load_config "$config_file" || return 1

  local backup_root_abs
  backup_root_abs=$(resolve_path "$config_backup_root" "$config_dir")
  local machine_dir="$backup_root_abs/$config_machine_id"

  expand_sources
  local -a sources=("${expanded_sources[@]}")

  if [[ ${#sources[@]} -eq 0 ]]; then
    log.warn "No valid sources to back up; skipping iteration"
    return 0
  fi

  local -a rsync_args=(--archive --delete --human-readable --partial --compress)
  (( verbose )) && rsync_args+=(-v)
  (( verbose || dry_run )) && rsync_args+=(--itemize-changes)
  (( dry_run )) && rsync_args+=(--dry-run)
  local pattern
  for pattern in "${config_exclude_patterns[@]-}"; do
    rsync_args+=("--exclude=$pattern")
  done

  if (( ! dry_run )); then
    mkdir -p "$machine_dir"
  fi

  local src dest_rel dest_dir dest_parent
  local -a failed=()
  for src in "${sources[@]}"; do
    dest_rel=$(relative_dest_path "$src")
    if [[ -d "$src" ]]; then
      dest_dir="$machine_dir/$dest_rel"
      if (( ! dry_run )); then
        mkdir -p "$dest_dir"
      fi
      local -a args=("${rsync_args[@]}")
      args+=("$src/" "$dest_dir/")
      if ! rsync "${args[@]}"; then
        log.error "rsync failed for directory: $src"
        failed+=("$src")
      fi
    else
      dest_parent=$(dirname -- "$dest_rel")
      if [[ "$dest_parent" == "." ]]; then
        dest_dir="$machine_dir"
      else
        dest_dir="$machine_dir/$dest_parent"
      fi
      if (( ! dry_run )); then
        mkdir -p "$dest_dir"
      fi
      local -a args=("${rsync_args[@]}")
      args+=("$src" "$dest_dir/")
      if ! rsync "${args[@]}"; then
        log.error "rsync failed for file: $src"
        failed+=("$src")
      fi
    fi
  done

  if (( dry_run )); then
    log.info "Dry run complete; backup would sync to $machine_dir"
    return 0
  fi

  local timestamp
  timestamp=$(date +"%Y%m%dT%H%M%S")
  local log_dir="$machine_dir/logs"
  mkdir -p "$log_dir"
  printf '%s|sources=%d|status=%s\n' "$timestamp" "${#sources[@]}" "$([[ ${#failed[@]} -eq 0 ]] && echo success || echo failure)" >>"$log_dir/history.log"

  if [[ ${#failed[@]} -gt 0 ]]; then
    log.error "Iteration completed with ${#failed[@]} failed rsync operations"
    return 1
  fi

  log.info "Backup synced to $machine_dir"
}

sleep_with_interrupt() {
  sleep "$1" &
  local sleep_pid=$!
  if ! wait "$sleep_pid"; then
    (( verbose )) && log.info "Sleep interrupted"
  fi
}

parse_args() {
  local opt
  local -a transformed=()

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --help) transformed+=('-h') ;;
      --verbose) transformed+=('-v') ;;
      --interval)
        shift
        [[ $# -gt 0 ]] || { log.error "--interval requires a value"; script.usage 1; }
        transformed+=('-i' "$1")
        shift
        continue
        ;;
      --interval=*)
        transformed+=('-i' "${1#*=}")
        shift
        continue
        ;;
      --config)
        shift
        [[ $# -gt 0 ]] || { log.error "--config requires a path"; script.usage 1; }
        config_path="$1"
        shift
        continue
        ;;
      --config=*)
        config_path="${1#*=}"
        shift
        continue
        ;;
      --dry-run)
        transformed+=('-n')
        ;;
      --oneshot)
        oneshot=1
        shift
        continue
        ;;
      --launchd-load)
        if [[ -n "$launchd_action" ]]; then
          log.error "Multiple launchd actions specified"
          script.usage 1
        fi
        launchd_action="load"
        shift
        continue
        ;;
      --launchd-unload)
        if [[ -n "$launchd_action" ]]; then
          log.error "Multiple launchd actions specified"
          script.usage 1
        fi
        launchd_action="unload"
        shift
        continue
        ;;
      --)
        shift
        break
        ;;
      --*)
        log.error "Unknown option: $1"
        script.usage 1
        ;;
      *)
        break
        ;;
    esac
    shift
  done

  transformed+=("$@")
  set -- "${transformed[@]}"

  while getopts ':hvni:' opt; do
    case "$opt" in
      h) script.usage ;;
      v) verbose=1 ;;
      n) dry_run=1 ;;
      i) interval="$OPTARG" ;;
      :) log.error "Option -$OPTARG requires an argument"; script.usage 1 ;;
      \?) log.error "Invalid option: -$OPTARG"; script.usage 1 ;;
    esac
  done

  shift $((OPTIND - 1))

  if [[ $# -gt 0 ]]; then
    log.error "Unexpected positional arguments"
    script.usage 1
  fi

  script.validate_positive_int "$interval" "--interval"
}

main() {
  if [[ "$launchd_action" == "load" ]]; then
    launchd_handle_load
    return
  fi

  if [[ "$launchd_action" == "unload" ]]; then
    launchd_handle_unload
    return
  fi

  ensure_prerequisites

  if [[ -z "$config_path" ]]; then
    log.error "No config provided; use --config or set COPYX_CONFIG"
    exit 1
  fi

  config_path=$(resolve_path "$config_path" "$PWD")

  if [[ ! -f "$config_path" ]]; then
    log.error "Config path not found: $config_path"
    exit 1
  fi

  local iteration=0

  while :; do
    iteration=$((iteration + 1))
    (( verbose )) && log.info "Iteration $iteration starting"

    if ! perform_backup_iteration "$config_path"; then
      log.error "Iteration $iteration failed"
    fi

    if (( oneshot )); then
      break
    fi

    if (( should_exit )); then
      (( verbose )) && log.info "Exit requested; stopping loop"
      break
    fi

    sleep_with_interrupt "$interval"

    if (( should_exit )); then
      (( verbose )) && log.info "Exit requested after sleep"
      break
    fi
  done
}

parse_args "$@"
main
