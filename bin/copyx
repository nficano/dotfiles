#!/usr/bin/env bash
#/ Execute hourly incremental rsync backups based on a YAML configuration.
#/
#/ Usage: $(basename "$0") [-h] [-v] [-n] [-i seconds] [--config path] [--oneshot]
#/
#/ Available options:
#/    -h, --help        Print this help and exit
#/    -v, --verbose     Enable verbose output
#/    -n, --dry-run     Run rsync in dry-run mode
#/    -i, --interval    Seconds between iterations (default 3600)
#/        --config      Path to YAML config (or COPYX_CONFIG env var)
#/        --oneshot     Run a single iteration then exit
#/        --launchd-load    Write LaunchAgent plist and load via launchctl
#/        --launchd-unload  Unload LaunchAgent via launchctl
#/
#/ Examples:
#/    $(basename "$0") --config ~/.config/copyx.yml
#/    COPYX_CONFIG=~/.config/copyx.yml $(basename "$0") --oneshot
#/
#/ Config keys:
#/    backup_root   Destination directory (path or s3:// URI) for synced data
#/    machine_id    Optional machine identifier (hostname used if omitted)
#/    sources       List of paths/globs to replicate
#/    exclude       Optional list of rsync exclude patterns

set -Eeuo pipefail
trap 'should_exit=1; cleanup' SIGINT SIGTERM
trap cleanup ERR EXIT

source "$(dirname "$0")/../lib/bash/initrc"

verbose=0
dry_run=0
interval=3600
oneshot=0
should_exit=0
config_path="${COPYX_CONFIG:-}"
launchd_action=""

readonly LAUNCHD_LABEL="com.nficano.copyx"
readonly LAUNCHD_PATH_VALUE="/usr/local/bin:/opt/homebrew/bin:/usr/bin:/bin:/usr/sbin:/sbin"

config_dir=""
config_backup_root=""
config_machine_id=""
config_sources=()
config_exclude_patterns=()
expanded_sources=()
backup_backend=""

cleanup() {
  script.cleanup
}
resolve_machine_id() {
  if [[ -n "$config_machine_id" ]]; then
    return
  fi

  local machine_id_file="$HOME/.machine_id"
  local candidate=""

  if os.machine_id.matches_current; then
    if [[ -f "$machine_id_file" ]]; then
      candidate=$(<"$machine_id_file")
      candidate=$(copyx.trim "$candidate")
    fi
    if [[ -n "$candidate" ]]; then
      config_machine_id="$candidate"
      log.info "Using machine identifier from $machine_id_file"
      return
    fi
    log.info "Machine identifier lookup returned empty result; falling back to hostname"
  fi

  config_machine_id=$(hostname -s 2>/dev/null || hostname)
  config_machine_id=$(copyx.trim "$config_machine_id")
  log.info "Config did not specify 'machine_id'; using hostname '$config_machine_id'"
}

launchd_domain() {
  printf 'gui/%s\n' "$(id -u)"
}

launchd_plist_path() {
  printf '%s/Library/LaunchAgents/%s.plist\n' "$HOME" "$LAUNCHD_LABEL"
}

launchd_logs_dir() {
  printf '%s/Library/Logs/copyx\n' "$HOME"
}

launchd_prepare_plist() {
  local config_file="$1" start_interval="$2"
  local plist_path log_dir script_path script_source script_dir
  plist_path=$(launchd_plist_path)
  log_dir=$(launchd_logs_dir)
  script_source="${BASH_SOURCE[0]}"
  script_dir=$(cd "$(dirname -- "$script_source")" && pwd -P)
  script_path=$(copyx.resolve_path "$(basename -- "$script_source")" "$script_dir")

  local script_xml config_xml path_xml stdout_xml stderr_xml stdout_path stderr_path
  script_xml=$(copyx.xml_escape "$script_path")
  config_xml=$(copyx.xml_escape "$config_file")
  path_xml=$(copyx.xml_escape "$LAUNCHD_PATH_VALUE")
  stdout_path="$log_dir/stdout.log"
  stderr_path="$log_dir/stderr.log"
  stdout_xml=$(copyx.xml_escape "$stdout_path")
  stderr_xml=$(copyx.xml_escape "$stderr_path")

  mkdir -p "$(dirname "$plist_path")" "$log_dir"

  cat >"$plist_path" <<EOF
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>Label</key>
    <string>${LAUNCHD_LABEL}</string>
    <key>ProgramArguments</key>
    <array>
        <string>${script_xml}</string>
        <string>--config</string>
        <string>${config_xml}</string>
        <string>--oneshot</string>
    </array>
    <key>EnvironmentVariables</key>
    <dict>
        <key>PATH</key>
        <string>${path_xml}</string>
    </dict>
    <key>StartInterval</key>
    <integer>${start_interval}</integer>
    <key>RunAtLoad</key>
    <true/>
    <key>StandardOutPath</key>
    <string>${stdout_xml}</string>
    <key>StandardErrorPath</key>
    <string>${stderr_xml}</string>
</dict>
</plist>
EOF

  chmod 0644 "$plist_path"

  if command -v plutil >/dev/null 2>&1; then
    if ! plutil -lint "$plist_path" >/dev/null 2>&1; then
      log.warn "plutil validation failed for $plist_path"
    fi
  fi

  printf '%s\n' "$plist_path"
}

launchd_handle_load() {
  if ! command -v launchctl >/dev/null 2>&1; then
    log.error "launchctl is required to manage LaunchAgents"
    exit 1
  fi

  local config="${config_path:-}"
  if [[ -z "$config" ]]; then
    config="$HOME/.config/copyx/config.yml"
    log.info "No config provided; defaulting to $config"
  fi

  config=$(copyx.resolve_path "$config" "$PWD")

  if [[ ! -f "$config" ]]; then
    log.error "Config path not found: $config"
    exit 1
  fi

  config_path="$config"

  local plist_path
  plist_path=$(launchd_prepare_plist "$config" "$interval")

  local domain
  domain=$(launchd_domain)

  if launchctl print "$domain/$LAUNCHD_LABEL" >/dev/null 2>&1; then
    if launchctl bootout "$domain" "$plist_path" >/dev/null 2>&1; then
      (( verbose )) && log.info "Unloaded existing LaunchAgent $LAUNCHD_LABEL"
    else
      log.warn "Failed to unload existing LaunchAgent $LAUNCHD_LABEL; attempting to continue"
    fi
  fi

  if ! launchctl bootstrap "$domain" "$plist_path"; then
    log.error "launchctl bootstrap failed for $plist_path"
    exit 1
  fi

  launchctl enable "$domain/$LAUNCHD_LABEL" >/dev/null 2>&1 || true

  if launchctl kickstart -k "$domain/$LAUNCHD_LABEL" >/dev/null 2>&1; then
    (( verbose )) && log.info "LaunchAgent $LAUNCHD_LABEL started"
  else
    log.warn "launchctl kickstart failed; agent will start on the next scheduled interval"
  fi

  log.info "LaunchAgent $LAUNCHD_LABEL loaded from $plist_path"
  return 0
}

launchd_handle_unload() {
  if ! command -v launchctl >/dev/null 2>&1; then
    log.error "launchctl is required to manage LaunchAgents"
    exit 1
  fi

  local plist_path
  plist_path=$(launchd_plist_path)

  local domain
  domain=$(launchd_domain)

  if launchctl print "$domain/$LAUNCHD_LABEL" >/dev/null 2>&1; then
    if launchctl bootout "$domain" "$plist_path" >/dev/null 2>&1; then
      log.info "LaunchAgent $LAUNCHD_LABEL unloaded"
    elif launchctl bootout "$domain/$LAUNCHD_LABEL" >/dev/null 2>&1; then
      log.info "LaunchAgent $LAUNCHD_LABEL unloaded"
    else
      log.error "Failed to unload LaunchAgent $LAUNCHD_LABEL"
      exit 1
    fi
  else
    log.info "LaunchAgent $LAUNCHD_LABEL not currently loaded"
  fi

  launchctl disable "$domain/$LAUNCHD_LABEL" >/dev/null 2>&1 || true

  if [[ -f "$plist_path" ]]; then
    if (( verbose )); then
      log.info "LaunchAgent plist remains at $plist_path"
    fi
  else
    log.warn "LaunchAgent plist not found at $plist_path"
  fi
  return 0
}

ensure_prerequisites() {
  if ! command -v yq >/dev/null 2>&1; then
    log.error "yq is required but not found in PATH"
    exit 1
  fi
}

load_config() {
  local file="$1"
  [[ -f "$file" ]] || { log.error "Config file not found: $file"; return 1; }

  config_dir=$(cd "$(dirname -- "$file")" && pwd -P)
  config_backup_root=$(copyx.trim "$(yq eval -r '.backup_root // ""' "$file" 2>/dev/null)")
  config_backup_root=$(copyx.expand_env "$config_backup_root")
  if [[ -n "${COPYX_BACKUP_ROOT:-}" ]]; then
    config_backup_root=$(copyx.expand_env "$COPYX_BACKUP_ROOT")
  fi
  config_machine_id=$(copyx.trim "$(yq eval -r '.machine_id // ""' "$file" 2>/dev/null)")
  config_machine_id=$(copyx.expand_env "$config_machine_id")
  config_sources=()
  config_exclude_patterns=()

  local sources_raw=""
  if ! sources_raw=$(yq eval -r '.sources // [] | .[]' "$file" 2>/dev/null); then
    log.error "Failed to parse 'sources' from config via yq"
    return 1
  fi

  local item
  if [[ -n "$sources_raw" ]]; then
    while IFS= read -r item || [[ -n "$item" ]]; do
      item=$(copyx.trim "$item")
      [[ -n "$item" ]] && config_sources+=("$(copyx.expand_env "$item")")
    done <<<"$sources_raw"
  fi

  local exclude_raw=""
  if ! exclude_raw=$(yq eval -r '.exclude // [] | .[]' "$file" 2>/dev/null); then
    log.error "Failed to parse 'exclude' from config via yq"
    return 1
  fi

  if [[ -n "$exclude_raw" ]]; then
    while IFS= read -r item || [[ -n "$item" ]]; do
      item=$(copyx.trim "$item")
      [[ -n "$item" ]] && config_exclude_patterns+=("$(copyx.expand_env "$item")")
    done <<<"$exclude_raw"
  fi

  if [[ -z "$config_backup_root" ]]; then
    log.error "Config missing required 'backup_root'"
    return 1
  fi

  resolve_machine_id
}

expand_sources() {
  expanded_sources=()
  local -a patterns=("${config_sources[@]}")
  if [[ ${#patterns[@]} -eq 0 ]]; then
    return
  fi

  local pattern prepared
  for pattern in "${patterns[@]}"; do
    prepared=$(copyx.pattern_to_glob "$pattern" "$config_dir")
    local -a matches=()
    while IFS= read -r match; do
      matches+=("$match")
    done < <(compgen -G "$prepared" 2>/dev/null || true)
    if [[ ${#matches[@]} -eq 0 ]]; then
      matches+=("$prepared")
    fi
    local match resolved
    for match in "${matches[@]}"; do
      if [[ -d "$match" || -f "$match" ]]; then
        resolved=$(copyx.resolve_path "$match")
        expanded_sources+=("$resolved")
      else
        log.warn "Source not found: $pattern (resolved to $match)"
      fi
    done
  done
}

perform_backup_iteration() {
  local config_file="$1"
  load_config "$config_file" || return 1

  backup_backend=$(copyx.backend_for_root "$config_backup_root")
  copyx.ensure_backend_prerequisites "$backup_backend"

  if copyx.on_battery_power; then
    log.info "Skipping backup while running on battery power"
    return 0
  fi

  local backup_root_abs
  if [[ "$backup_backend" == "s3" ]]; then
    backup_root_abs=$(copyx.strip_trailing_slashes "$config_backup_root")
  else
    backup_root_abs=$(copyx.resolve_path "$config_backup_root" "$config_dir")
    backup_root_abs=$(copyx.strip_trailing_slashes "$backup_root_abs")
  fi

  local machine_dir
  machine_dir=$(copyx.join_paths "$backup_root_abs" "$config_machine_id")
  machine_dir=$(copyx.strip_trailing_slashes "$machine_dir")

  expand_sources
  local -a sources=("${expanded_sources[@]}")

  if [[ ${#sources[@]} -eq 0 ]]; then
    log.warn "No valid sources to back up; skipping iteration"
    return 0
  fi

  local -a failed=()

  local -a rsync_args=()
  local -a s3_common_opts=()
  local pattern
  if [[ "$backup_backend" == "local" ]]; then
    rsync_args=(--archive --delete --human-readable --partial --compress)
    (( verbose )) && rsync_args+=(-v)
    (( verbose || dry_run )) && rsync_args+=(--itemize-changes)
    (( dry_run )) && rsync_args+=(--dry-run)
    for pattern in "${config_exclude_patterns[@]-}"; do
      rsync_args+=("--exclude=$pattern")
    done
    if (( ! dry_run )); then
      mkdir -p "$machine_dir"
    fi
  else
    (( dry_run )) && s3_common_opts+=(--dryrun)
    (( ! verbose )) && s3_common_opts+=(--only-show-errors)
    (( verbose )) && s3_common_opts+=(--debug)
  fi

  local src dest_rel dest_dir dest_parent
  for src in "${sources[@]}"; do
    dest_rel=$(copyx.relative_dest_path "$src")
    if [[ "$backup_backend" == "local" ]]; then
      if [[ -d "$src" ]]; then
        dest_dir=$(copyx.join_paths "$machine_dir" "$dest_rel")
        if (( ! dry_run )); then
          mkdir -p "$dest_dir"
        fi
        local -a args=("${rsync_args[@]}")
        args+=("$src/" "$dest_dir/")
        if ! rsync "${args[@]}"; then
          log.error "rsync failed for directory: $src"
          failed+=("$src")
        fi
      else
        dest_parent=$(dirname -- "$dest_rel")
        if [[ "$dest_parent" == "." ]]; then
          dest_dir="$machine_dir"
        else
          dest_dir=$(copyx.join_paths "$machine_dir" "$dest_parent")
        fi
        if (( ! dry_run )); then
          mkdir -p "$dest_dir"
        fi
        local -a args=("${rsync_args[@]}")
        args+=("$src" "$dest_dir/")
        if ! rsync "${args[@]}"; then
          log.error "rsync failed for file: $src"
          failed+=("$src")
        fi
      fi
    else
      local dest_uri
      dest_uri=$(copyx.join_paths "$machine_dir" "$dest_rel")
      if [[ -d "$src" ]]; then
        local -a sync_opts=("${s3_common_opts[@]}" --delete --exact-timestamps)
        for pattern in "${config_exclude_patterns[@]-}"; do
          sync_opts+=(--exclude "$pattern")
        done
        if ! aws s3 sync "$src/" "$dest_uri/" "${sync_opts[@]}"; then
          log.error "aws s3 sync failed for directory: $src"
          failed+=("$src")
        fi
      else
        if ! aws s3 cp "$src" "$dest_uri" "${s3_common_opts[@]}"; then
          log.error "aws s3 cp failed for file: $src"
          failed+=("$src")
        fi
      fi
    fi
  done

  if (( dry_run )); then
    log.info "Dry run complete; backup would sync to $machine_dir"
    return 0
  fi

  local timestamp status entry
  timestamp=$(date +"%Y%m%dT%H%M%S")

  if [[ ${#failed[@]} -eq 0 ]]; then
    status="success"
  else
    status="failure"
  fi

  entry="$timestamp|sources=${#sources[@]}|status=$status"

  if [[ "$backup_backend" == "local" ]]; then
    local log_dir
    log_dir=$(copyx.join_paths "$machine_dir" "logs")
    mkdir -p "$log_dir"
    printf '%s\n' "$entry" >>"$(copyx.join_paths "$log_dir" "history.log")"
  else
    copyx.update_s3_history_log "$machine_dir" "$entry"
  fi

  if [[ ${#failed[@]} -gt 0 ]]; then
    log.error "Iteration completed with ${#failed[@]} failed ${backup_backend} operations"
    return 1
  fi

  log.info "Backup synced to $machine_dir"
}

sleep_with_interrupt() {
  sleep "$1" &
  local sleep_pid=$!
  if ! wait "$sleep_pid"; then
    (( verbose )) && log.info "Sleep interrupted"
  fi
}

parse_args() {
  local opt
  local -a transformed=()

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --help) transformed+=('-h') ;;
      --verbose) transformed+=('-v') ;;
      --interval)
        shift
        [[ $# -gt 0 ]] || { log.error "--interval requires a value"; script.usage 1; }
        transformed+=('-i' "$1")
        shift
        continue
        ;;
      --interval=*)
        transformed+=('-i' "${1#*=}")
        shift
        continue
        ;;
      --config)
        shift
        [[ $# -gt 0 ]] || { log.error "--config requires a path"; script.usage 1; }
        config_path="$1"
        shift
        continue
        ;;
      --config=*)
        config_path="${1#*=}"
        shift
        continue
        ;;
      --dry-run)
        transformed+=('-n')
        ;;
      --oneshot)
        oneshot=1
        shift
        continue
        ;;
      --launchd-load)
        if [[ -n "$launchd_action" ]]; then
          log.error "Multiple launchd actions specified"
          script.usage 1
        fi
        launchd_action="load"
        shift
        continue
        ;;
      --launchd-unload)
        if [[ -n "$launchd_action" ]]; then
          log.error "Multiple launchd actions specified"
          script.usage 1
        fi
        launchd_action="unload"
        shift
        continue
        ;;
      --)
        shift
        break
        ;;
      --*)
        log.error "Unknown option: $1"
        script.usage 1
        ;;
      *)
        break
        ;;
    esac
    shift
  done

  transformed+=("$@")
  set -- "${transformed[@]}"

  while getopts ':hvni:' opt; do
    case "$opt" in
      h) script.usage ;;
      v) verbose=1 ;;
      n) dry_run=1 ;;
      i) interval="$OPTARG" ;;
      :) log.error "Option -$OPTARG requires an argument"; script.usage 1 ;;
      \?) log.error "Invalid option: -$OPTARG"; script.usage 1 ;;
    esac
  done

  shift $((OPTIND - 1))

  if [[ $# -gt 0 ]]; then
    log.error "Unexpected positional arguments"
    script.usage 1
  fi

  script.validate_positive_int "$interval" "--interval"
}

main() {
  if [[ "$launchd_action" == "load" ]]; then
    launchd_handle_load
    return
  fi

  if [[ "$launchd_action" == "unload" ]]; then
    launchd_handle_unload
    return
  fi

  ensure_prerequisites

  if [[ -z "$config_path" ]]; then
    log.error "No config provided; use --config or set COPYX_CONFIG"
    exit 1
  fi

  config_path=$(copyx.resolve_path "$config_path" "$PWD")

  if [[ ! -f "$config_path" ]]; then
    log.error "Config path not found: $config_path"
    exit 1
  fi

  local iteration=0

  while :; do
    iteration=$((iteration + 1))
    (( verbose )) && log.info "Iteration $iteration starting"

    if ! perform_backup_iteration "$config_path"; then
      log.error "Iteration $iteration failed"
    fi

    if (( oneshot )); then
      break
    fi

    if (( should_exit )); then
      (( verbose )) && log.info "Exit requested; stopping loop"
      break
    fi

    sleep_with_interrupt "$interval"

    if (( should_exit )); then
      (( verbose )) && log.info "Exit requested after sleep"
      break
    fi
  done
}

parse_args "$@"
main
