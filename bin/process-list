#!/usr/bin/env bash
#/ Render a colorful, grouped application process listing.
#/
#/ Usage: $(basename "$0") [-h] [-v]
#/
#/ Available options:
#/    -h, --help     Print this help and exit
#/    -v, --verbose  Enable verbose output
#/
set -Eeuo pipefail
trap script.cleanup SIGINT SIGTERM ERR EXIT

source "$(dirname "$0")/../lib/bash/initrc"

script_dir=$(cd "$(dirname "${BASH_SOURCE[0]}")" &>/dev/null && pwd -P)

verbose=0

parse_args() {
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -h|--help)
        script.usage
        ;;
      -v|--verbose)
        verbose=1
        ;;
      --)
        shift
        break
        ;;
      -*)
        log.error "Unknown option: $1"
        script.usage 1
        ;;
      *)
        break
        ;;
    esac
    shift
  done
}

collect_process_lines() {
  python3 <<'PYCODE'
import ctypes
import os
import subprocess
import sys
from pathlib import Path

HOME = os.path.expanduser("~")
ROOTS = ["/Applications", HOME]

PROC_PIDPATHINFO_MAXSIZE = 4096

def iter_pids():
    try:
        output = subprocess.check_output(["ps", "-Ao", "pid="], text=True)
    except subprocess.CalledProcessError:
        return []
    return [int(line) for line in output.splitlines() if line.strip().isdigit()]

if sys.platform.startswith("darwin"):
    libproc = ctypes.CDLL("/usr/lib/libproc.dylib", use_errno=True)

    def get_exe(pid):
        buf = ctypes.create_string_buffer(PROC_PIDPATHINFO_MAXSIZE)
        ret = libproc.proc_pidpath(pid, buf, PROC_PIDPATHINFO_MAXSIZE)
        if ret <= 0:
            return ""
        return buf.value.decode("utf-8", "ignore")
elif sys.platform.startswith("linux"):
    def get_exe(pid):
        try:
            return os.readlink(f"/proc/{pid}/exe")
        except OSError:
            return ""
else:
    def get_exe(pid):
        return ""


def path_under_roots(path: str) -> bool:
    return any(
        path == root or path.startswith(root + os.sep)
        for root in ROOTS
    )


def derive_group(path: Path):
    for part in path.parts:
        if part.endswith(".app"):
            return part[:-4]

    try:
        if str(path).startswith(HOME):
            relative = path.relative_to(HOME)
            if relative.parts:
                first = relative.parts[0]
                return first[:-4] if first.endswith(".app") else first
            return path.name
    except ValueError:
        pass

    name = path.stem
    return name or None


groups = {}

for pid in iter_pids():
    path_value = get_exe(pid)
    if not path_value:
        continue

    try:
        real_path = Path(os.path.realpath(path_value))
    except OSError:
        continue

    path_str = str(real_path)
    if not path_under_roots(path_str):
        continue

    group = derive_group(real_path)
    if not group:
        continue

    name = real_path.name.rstrip("/")
    if name.endswith(".app"):
        name = name[:-4]

    if name in {"Contents", "MacOS", "Frameworks", "Library", "Resources"}:
        continue

    groups.setdefault(group, []).append((pid, name))

for group_name in sorted(groups):
    entries = sorted(groups[group_name], key=lambda item: item[0])
    for pid, proc_name in entries:
        print(f"{group_name}\t{pid}\t{proc_name}")
PYCODE
}

render_processes() {
  local current_group=""
  local found=0
  local group pid name

  while IFS=$'\t' read -r group pid name; do
    [[ -z "${group:-}" ]] && continue

    if [[ "$group" != "$current_group" ]]; then
      [[ -n "$current_group" ]] && printf '\n'
      current_group="$group"
      printf '%s\n' "$(ui.ansi.wrap '1;34' "${group}:")"
    fi

    local pid_colored name_colored
    pid_colored=$(ui.ansi.wrap '32' "$pid")
    name_colored=$(ui.ansi.wrap '97' "$name")
    printf '  %s %s\n' "$pid_colored" "$name_colored"
    found=1
  done < <(collect_process_lines)

  (( found )) || log.warn "No matching processes under /Applications or $HOME"
}

main() {
  require.cmd python3
  (( verbose )) && log.info "Scanning active processes"
  render_processes
}

parse_args "$@"
main
