#!/bin/bash
#/ Kill the process currently listening on the given TCP port.
#/
#/ NAME
#/      {{ basename }} -- Kill a process running on a specified port.
#/
#/ SYNOPSIS
#/      {{ basename }} [-h] [--help]
#/      {{ basename }} <port>
#/
#/ DESCRIPTION
#/      This script finds and kills a process that is currently listening on
#/      the specified TCP port. It is useful in situations where you need to
#/      free up a port that is being used by an unresponsive or unwanted process.
#/      The script takes a single argument, which is the port number.
#/
#/      Arguments:
#/      <port>  The port number to search for a listening process.
#/      --help  Display this help message and exit.

set -o errexit # Exit on most errors (see the manual)
set -o nounset # Disallow expansion of unset variables

#set -o errtrace        # Make sure any error trap is inherited (BASH only)
#set -o pipefail        # Use last non-zero exit code in a pipeline (BASH only)
#set -o xtrace          # Trace the execution of the script (UNCOMMENT TO DEBUG)

usage() {
  grep '^#/ ' <"$0" | cut -c4- | sed "s/{{ basename }}/${0##*/}/"
  exit 0
}

if [ "$#" -ne 1 ]; then
  usage
fi

if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
  usage
fi

PORT="$1"

# Find the PID(s) of the process(es) using the specified port
PIDS=$(lsof -t -iTCP:"$PORT" -sTCP:LISTEN)

# Check if a process was found
if [ -z "$PIDS" ]; then
  echo "No process found running on port $PORT"
  exit 1
fi

# Kill all processes (handle multiple PIDs)
KILLED_COUNT=0
FAILED_COUNT=0

for PID in $PIDS; do
  if kill -9 "$PID" 2>/dev/null; then
    KILLED_COUNT=$((KILLED_COUNT + 1))
  else
    FAILED_COUNT=$((FAILED_COUNT + 1))
  fi
done

# Confirm the results
if [ $FAILED_COUNT -eq 0 ]; then
  if [ $KILLED_COUNT -eq 1 ]; then
    echo "Process on port $PORT has been killed."
  else
    echo "$KILLED_COUNT processes on port $PORT have been killed."
  fi
else
  echo "Failed to kill $FAILED_COUNT process(es) on port $PORT."
  exit 1
fi
