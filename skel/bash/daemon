#!/usr/bin/env bash
#/ {{ description }}
#/
#/ Usage: $(basename "$0") [-h] [-v] [-i seconds] [--oneshot]
#/
#/ Available options:
#/    -h, --help      Print this help and exit
#/    -v, --verbose   Enable verbose output
#/    -i, --interval  Seconds between iterations (default 30)
#/        --oneshot   Run a single iteration then exit
#/
#/ Examples:
#/    $(basename "$0")
#/    $(basename "$0") --interval 10 --oneshot

set -Eeuo pipefail
trap 'should_exit=1; cleanup' SIGINT SIGTERM
trap cleanup ERR EXIT

source "$(dirname "$0")/../lib/bash/initrc"

script_dir=$(cd "$(dirname "${BASH_SOURCE[0]}")" &>/dev/null && pwd -P)

verbose=0
interval=30
oneshot=0
should_exit=0

cleanup() {
  script.cleanup
}

parse_args() {
  local opt
  local -a transformed=()

  while [[ $# -gt 0 ]]; do
    case "$1" in
    --help) transformed+=('-h') ;;
    --verbose) transformed+=('-v') ;;
    --interval)
      shift
      [[ $# -gt 0 ]] || {
        log.error "--interval requires a value"
        script.usage 1
      }
      transformed+=('-i' "$1")
      shift
      continue
      ;;
    --interval=*)
      transformed+=('-i' "${1#*=}")
      shift
      continue
      ;;
    --oneshot)
      oneshot=1
      shift
      continue
      ;;
    --)
      shift
      break
      ;;
    --*)
      log.error "Unknown option: $1"
      script.usage 1
      ;;
    *)
      break
      ;;
    esac
    shift
  done

  transformed+=("$@")
  set -- "${transformed[@]}"

  while getopts ':hvi:' opt; do
    case "$opt" in
    h) script.usage ;;
    v) verbose=1 ;;
    i) interval="$OPTARG" ;;
    :)
      log.error "Option -$OPTARG requires an argument"
      script.usage 1
      ;;
    \?)
      log.error "Invalid option: -$OPTARG"
      script.usage 1
      ;;
    esac
  done

  shift $((OPTIND - 1))

  if [[ $# -gt 0 ]]; then
    log.error "Unexpected positional arguments"
    script.usage 1
  fi

  script.validate_positive_int "$interval" "--interval"
}

main() {
  local iteration=0

  while :; do
    iteration=$((iteration + 1))
    ((verbose)) && log.info "Iteration $iteration"

    log.info "Running iteration $iteration"
    # TODO: perform recurring work here

    if ((oneshot)); then
      break
    fi

    if ((should_exit)); then
      ((verbose)) && log.info "Exit requested; stopping loop"
      break
    fi

    sleep "$interval" &
    local sleep_pid=$!
    if ! wait "$sleep_pid"; then
      ((verbose)) && log.info "Sleep interrupted"
    fi

    if ((should_exit)); then
      ((verbose)) && log.info "Exit requested after sleep"
      break
    fi
  done
}

parse_args "$@"
main
